<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>亚文化网站研究</title>
    <url>/2020/04/05/%E4%BA%9A%E6%96%87%E5%8C%96%E7%BD%91%E7%AB%99%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<p>AO3 asianfanfics wattpad</p>
<a id="more"></a>

<p>怪谈<br>New weird<br>与其他网络文学平台相比，被逼停的AO3（图①）的最大特点是大多数作品为“同人”小说。“同人”一词源自日本，原意为“志同道合之人”，现在一般指基于已经存在的作品或人物进行创作的衍生物，比如美国推理小说家埃勒里·奎因的《恐怖的研究》是福尔摩斯系列同人，好莱坞电影《五十度灰》原作小说是《暮光之城》同人。与“改编”不同，同人一般包括作者自己添加的内容，基本可以看作为独立作品。截至2019年，AO3网站上有基于3.5万种原作的550万部作品，包括动漫游戏、影视剧、体育界、经典文学等细分类别。因不少作者对科学研究感兴趣，AO3上也不乏学术报告、研究论文等。</p>
<p>作为青年亚文化圈最重要的组成部分，同人创作通常体现年轻人创作中“非专业”“草根文化”等特点。因其非商业的性质，这些创作常被戏称为“为爱发电”——在某一个圈内的爱好者愿自掏腰包去维持圈子的存在。以AO3为例，从2008年创建之始，其运营完全靠网民捐助，没有任何广告营销。发展至今，有些同人作品逐渐走向“正统”，例如美国科幻IP《星际迷航》曾有一部同人续集剧，其中有演员是原饰演者的儿子，工作人员中也有专业的美国配音演员。AO3的创始人娜奥米·诺维克本身也是一名同人作家，她原创的长篇奇幻小说《连根拔起》获得2016年科幻文学大奖星云奖。AO3平台本身也获得2019年雨果奖“最佳相关工作”奖。</p>
<p>除了AO3之外，世界各地有不少类似平台，例如加拿大的Wattpad、以亚洲为主的AsianFanfics、日本的Pixiv、Niconico等。不同平台对于作品形式有不同重点，例如Pixiv主要是漫画、插画作品创作，也设有小说版块。同为日本的Niconico“弹幕”视频网则主要是视频剪辑、网络音乐等。另外像LiveJournal、FC2等社群平台原并非直接针对亚文化圈，目前也成为亚文化群体的聚集地。</p>
<p>成立于2004年的“成为小说家吧”（图②）是日本最大投稿网站。2015年，该网站登录人数突破55万人，2019年阅读人数达1400万人，其中20岁左右读者占近一半。科幻、异世界、恋爱、魔法、冒险、重生、校园、架空，日本小说网站作品分类十分详细。</p>
<p>在韩国，Munpia和Joara是网络小说平台两大巨头。2012年以武侠小说起家的Munpia，截至2019年11月注册用户已超过90万，以男性读者居多，题材上奇幻、体育游戏、武侠类小说各占一定比重。2011年创建的Joara网站，则以浪漫爱情、穿越、讽刺类小说居多，还专设“BL（BoysLove）”小说分类，是韩国为数不多刊载此类小说的平台。韩国第一代武侠小说家、Munpia网站CEO金焕哲表示：“看网络小说和网漫已成为韩国年轻人的日常习惯，网络小说改编成电视剧、电影和游戏的趋势业已形成，近年热门韩剧《成均馆绯闻》《云画的月光》（图③）《正义之刃》等均改编自人气网络小说。所以，未来网络小说市场发展空间仍很巨大。”</p>
<h3 id="asianfanfics"><a href="#asianfanfics" class="headerlink" title="asianfanfics"></a>asianfanfics</h3><p><strong>**</strong>个人主页<strong>**</strong><br>/profile<br>    /view/<br>        /:userid<br><strong>**</strong>个人主页_故事<strong>**</strong><br>        /view_author_stories<br>            /:userid</p>
<p><strong>**</strong>个人主页_博客<strong>**</strong><br>    /blog<br>        /index/:userid</p>
<p><strong>**</strong>个人主页_feed<strong>**</strong><br>/feed<br>    /[tag,user,followed,followers]<br>        /:userid<br><strong>**</strong>个人主页_书签<strong>**</strong><br>/bookmark<br>    /view<br>        /:userid<br><strong>**</strong>个人主页_投票<strong>**</strong><br>/vote<br>    /view<br>        /:userid<br><strong>**</strong>个人主页_标签<strong>**</strong><br>/label<br>    /view<br>        /:userid<br><strong>**</strong>个人主页_评论<strong>**</strong><br>/user_comments<br>    /[stories,blogs,polls,videos,images]<br>        /:userid<br><strong>**</strong>个人主页_相册/视频<strong>**</strong><br>/[album,video]<br>    /user<br>        /:userid<br><strong>**</strong>个人主页_朋友<strong>**</strong><br>/friends<br>    /view<br>        /:userid<br><strong>**</strong>个人主页_历史<strong>**</strong><br>    /history<br>    /profile_history</p>
<p><strong>**</strong>站内货币<strong>****</strong><br>    /account<br>        /view_karma_history<br>            /:userid</p>
<p>/browse<br>    /featured<br>    /trending<br>    /recommended<br>    /views<br>    ?filter=[all, crowdfunded, featured, ratedfeaatured, undiscovered, completed, oneshots]<br>    &amp;sort=[ latest, newest, views, subscriptions, comments,chaptercounts,worddcounts,votes]<br>    &amp;tag=[]<br>    &amp;pageNum=[1,2,3,4…]</p>
<hr>
<pre><code>/tag
    /tagname</code></pre><hr>
<pre><code>/users
/whos_online
/pop_authors
/streakranking</code></pre><p>/pm<br>    /inbox<br>        /:userid<br>    /sent<br>        /:userid</p>
<p>/story<br>    /create<br>    /view_random<br>    /view<br>        /:storyid<br>            /:forword||:chapter</p>
<p>/feed<br>    /story_feed<br>        /:userid<br>    /tag<br>        /:userid<br>/blog<br>    /add<br>    /view<br>        /:blog_id/:blog_title<br>/chat<br>    /add</p>
<h3 id="wattpad"><a href="#wattpad" class="headerlink" title="wattpad"></a>wattpad</h3>]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>毒</title>
    <url>/2020/04/04/%E6%AF%92/</url>
    <content><![CDATA[<p>我变成一剂毒药 只是不想随随便便被猛兽吃掉</p>
<a id="more"></a>
<h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><p>16岁的刘星和妈妈一起去海外度假，在酒店checking的时候，遇到了夏东海。夏东海和刘梅三年前离了婚。刘星遇到了夏雨，他不再活泼</p>
<p>原来三年前，夏雪被人强暴，与这件事情有关联的人都陷入了深深的自责。</p>
<p>夏东海应付酒局没有接到女儿的电话<br>刘梅本来应该在去接夏雪，但她和朋友去抢购打折衣服<br>夏雨躲了起来，没有救姐姐</p>
<p>很多年以后，刘星才承认，那伙人是他引过去的，只是他不知道那些人是禽兽。</p>
<p>夏东海和刘梅离婚了，夏雪也从一个乖学生变成了坏女孩，</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>夏雪喝酒</p>
<p>##</p>
<p>男人说只要刘星敢把虫子吃下去，他就把夏雪让给他。刘星最后还是怂了<br>刘星把男子一脚踹进泉水，拉着夏雪离开。夏雪让他滚蛋，</p>
<p>##</p>
<p>在回程的船上，夏雪和刘星作别，他们听人说，有几个年轻人昨晚死在了岛上，刘星开始以为自己又闯祸了。后来才知道，那个富家男孩与人打赌，吃了那个蝴蝶的幼虫，毒发身亡。<br>别人议论，那种蝴蝶虽然美丽，为了保护自己，他每天都吃有毒的东西，最后他的身上也都是剧毒。猎食者很可怕，有各种狡猾的方法诱捕你，你生活在丛林，怎么防范都无济于事，把自己变成一副毒药，也许是最好的方法。</p>
<p>刘星莫名其妙的满脸泪水，他看了夏雪一眼，发现她也一样。</p>
]]></content>
  </entry>
  <entry>
    <title>网络</title>
    <url>/2017/02/10/%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>结合《网络是怎样连接的》（户根勤著）和《图解HTTP》（上野宣著）做的笔记</p>
<a id="more"></a>
<h1 id="浏览器内部"><a href="#浏览器内部" class="headerlink" title="浏览器内部"></a>浏览器内部</h1><h2 id="生成HTTP请求"><a href="#生成HTTP请求" class="headerlink" title="生成HTTP请求"></a>生成HTTP请求</h2><h3 id="输入网址"><a href="#输入网址" class="headerlink" title="输入网址"></a>输入网址</h3><ul>
<li>浏览器即是客户端的应用程序，输入的URL就是程序的指令，指令既可以是拜托它传递的信息。也可以是让它处理的信息</li>
<li>浏览器是一个具备多种客户端功能的综合性客户端软件，因此它需要一些东西来判断应该使用其中哪种功能来访问相应的数据，而各种不同的 URL 就是用来干这个的<ol>
<li>http协议克以访问Web服务器</li>
<li>ftp协议可以下载和上传文件</li>
<li>file读取客户端计算机本地文件</li>
<li>mailto发送电子邮件</li>
<li>可以把这些称为协议类型</li>
</ol>
</li>
</ul>
<h3 id="浏览器解析URL"><a href="#浏览器解析URL" class="headerlink" title="浏览器解析URL"></a>浏览器解析URL</h3><ul>
<li><a href="http://www.lab.glasscom.com/dir/file1.html" target="_blank" rel="noopener">http://www.lab.glasscom.com/dir/file1.html</a></li>
<li><code>http:</code>是协议的写法</li>
<li><code>//</code>表示后面的字符串是服务器的名称</li>
<li><code>/dir/file1.html</code>是linux的写法，表示数据源（文件）的路径</li>
</ul>
<h3 id="省略文件名的几种情况"><a href="#省略文件名的几种情况" class="headerlink" title="省略文件名的几种情况"></a>省略文件名的几种情况</h3><ul>
<li><code>http://www.lab.glasscom.com/dir/</code> 目录后面的文件名省略了，服务器会事先设置好如果文件名被省略，会访问的默认文件名（比如dir下的index.html和default.htm）</li>
<li><code>http://www.lab.glasscom.com/</code> 就是访问<code>根目录</code>下的index.html或者default.htm</li>
<li><code>http://www.lab.glasscom.com</code> 连路径<code>/</code>都省略了，表示访问根目录下事先设置的默认文件</li>
</ul>
<h3 id="HTTP的基本思路"><a href="#HTTP的基本思路" class="headerlink" title="HTTP的基本思路"></a>HTTP的基本思路</h3><ol>
<li>客户端向服务器发送请求，请求包含<code>对什么</code>（URL）和<code>进行怎样的操作</code>(method)两个部分</li>
<li>HTTP消息中还有一些用来表示附加信息的头字段。客户端向 Web 服务器发送数据时，会先发送头字段，然后再发送数据。</li>
<li>收到请求后，web服务器会对请求内容进行解析，根据URL和method进行工作，然后将<code>状态码+头字段+网页数据</code>发送回客户端。</li>
<li>浏览器解析发送回来的数据，呈现出页面。</li>
<li>GET方法<ul>
<li>发送url，让服务器读取相应的数据。</li>
<li>服务器读取数据，把数据存放在相应信息中发送回来</li>
</ul>
</li>
<li>POST方法<ul>
<li>url会指向web服务器运行的一个应用程序的文件名，比如index.cgi, index.php</li>
<li>发送请求时，除了url，还要加上传递给应用程序的数据</li>
<li>服务器收到消息后，会将数据发送给url指定的应用程序。</li>
<li>服务器将应用程序的输出结果，存放在响应信息中返回客户端<h3 id="包含图片的页面"><a href="#包含图片的页面" class="headerlink" title="包含图片的页面"></a>包含图片的页面</h3></li>
</ul>
</li>
<li>浏览器先发送url请求</li>
<li>服务器返回响应消息和html内容</li>
<li>浏览器解析html，发现有img标签，就在生成页面时，预留好空间</li>
<li>浏览器在此向服务器发送请求，访问服务器里的静态资源（图片等），每次请求只能访问一张图片</li>
<li>服务器将静态资源返回给客户端，也包括状态码、头文件和主体，头文件包括资源的MIME类型，写在Content-Type里比如<code>Content-Type: image/jpeg</code>,主体部分是图片的<strong>二进制</strong>数据</li>
</ol>
<h2 id="向DNS查询IP地址"><a href="#向DNS查询IP地址" class="headerlink" title="向DNS查询IP地址"></a>向DNS查询IP地址</h2><h3 id="IP地址的基本知识"><a href="#IP地址的基本知识" class="headerlink" title="IP地址的基本知识"></a>IP地址的基本知识</h3><ul>
<li>子网相当于门牌号</li>
<li>子网下的主机相当于房间号</li>
<li>子网（集线器）— 最近的路由器 – 子网（集线器）– 最近的路由器 ….</li>
<li>实际的IP地址是由四个8bit数构成，比如202.205.12.13,但我们不知道哪组数字是网络号，哪组数字是主机号，所以需要子网掩码</li>
<li>子网掩码也是由四组8bit数构成，如255.255.255.255.0，255表示1，表示该位置上的数字为网络号，0表示该位置上的数字为主机号</li>
<li>也可以用十进制表示子网掩码，如10.11.12.13/24，</li>
<li>如果主机号部分全部为0，则代表整个子网，而不是子网中的某台设备</li>
<li>如果主机号部分全部为1，则代表向子网上所有设备发送包，即广播</li>
</ul>
<h3 id="域名和IP地址并用的理由"><a href="#域名和IP地址并用的理由" class="headerlink" title="域名和IP地址并用的理由"></a>域名和IP地址并用的理由</h3><ul>
<li>用IP地址代替域名可以工作，但不好记</li>
<li>用域名代替IP地址，会加大路由器的处理负担</li>
<li>为了填补两者之间的障碍，需要有一个机制能够通过名称来查询IP地址，或者通过IP 地址来查询名称，这样就能够在人和机器双方都不做出牺牲的前提下完美地解决问题。这个机制就是DNS</li>
</ul>
<h3 id="通过解析器向DNS服务器发出查询"><a href="#通过解析器向DNS服务器发出查询" class="headerlink" title="通过解析器向DNS服务器发出查询"></a>通过解析器向DNS服务器发出查询</h3><ul>
<li>操作系统都有DNS的客户端，称为DNS解析器，程序都在socket库里,应用程序直接调用就可以</li>
<li>解析器（DNS客户端）向DNS服务器发送查询信息</li>
<li>DNS服务器会返回响应消息。响应消息中包含查询到的IP地址</li>
<li>解析器会取出IP地址，并将其写入浏览器指定的内存地址中。</li>
</ul>
<h2 id="委托协议栈发送信息"><a href="#委托协议栈发送信息" class="headerlink" title="委托协议栈发送信息"></a>委托协议栈发送信息</h2><h3 id="收发数据的操作"><a href="#收发数据的操作" class="headerlink" title="收发数据的操作"></a>收发数据的操作</h3><ul>
<li>创建套接字</li>
<li>将管道连接到服务器端的套接字上</li>
<li>收发数据</li>
<li>断开管道并删除套接字</li>
</ul>
<h3 id="创建套接字阶段"><a href="#创建套接字阶段" class="headerlink" title="创建套接字阶段"></a>创建套接字阶段</h3><ul>
<li>一台计算机上可以创建多个套接字，用于同时连接多个网络服务(打开多个网页等)</li>
<li>计算机的协议栈通过<strong>描述符</strong>来判断用哪一个套接字来连接或者收发数据</li>
<li>描述符可以看成酒店寄存行李的号码牌</li>
</ul>
<h3 id="连接阶段：把管道接上去"><a href="#连接阶段：把管道接上去" class="headerlink" title="连接阶段：把管道接上去"></a>连接阶段：把管道接上去</h3><ul>
<li>应用程序调用Socket库中connect组件来完成操作，调用时，制定三个参数：描述符、服务器IP地址、端口号</li>
<li>描述符是本地协议栈与应用程序交互使用的，不能用于网络连接</li>
<li>IP地址是用来定位具体计算机（服务器）的</li>
<li>端口号是用来定位另一段某个具体的套接字的，服务器上所使用的端口号是根据应用的种类事先规定好的。比如 Web 是80号端口，电子邮件是25号端口。</li>
</ul>
<h3 id="通信阶段：传递信息"><a href="#通信阶段：传递信息" class="headerlink" title="通信阶段：传递信息"></a>通信阶段：传递信息</h3><ul>
<li>应用程序在内存中准备好要发送的数据。</li>
<li>指定描述符，描述符对应套接字</li>
<li>发送数据</li>
<li>服务器接收数据</li>
</ul>
<h3 id="断开阶段"><a href="#断开阶段" class="headerlink" title="断开阶段"></a>断开阶段</h3><ul>
<li>打开一个网页如果包含多张图片，就必须重复进行很多次连接 - 收发 - 断开的操作。</li>
<li>因此人们设计出了能够在一次连接中收发多个请求和响应的方法。</li>
</ul>
<h1 id="协议栈和网卡"><a href="#协议栈和网卡" class="headerlink" title="协议栈和网卡"></a>协议栈和网卡</h1><h2 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h2><h3 id="协议栈内部结构"><a href="#协议栈内部结构" class="headerlink" title="协议栈内部结构"></a>协议栈内部结构</h3><ul>
<li>应用程序产生数据收发的需求</li>
<li>Socket库连接</li>
<li>操作系统内部（协议栈）：TCP用于浏览器、邮件等应用程序收发数据，UDP用于DNS查询等收发较短的控制数据</li>
<li>用IP协议控制网络包收发，将数据分切成一个个小包</li>
<li>网卡完成实际收发操作</li>
</ul>
<h3 id="套接字实体就是通信控制信息"><a href="#套接字实体就是通信控制信息" class="headerlink" title="套接字实体就是通信控制信息"></a>套接字实体就是通信控制信息</h3><ul>
<li>在协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于 控制通信操作的控制信息，例如通信对象的 IP 地址、端口号、通信操作的 进行状态等，这些控制信息就是套接字</li>
<li>协议栈执行操作需要参照套接字信息</li>
</ul>
<h3 id="调用socket时的操作"><a href="#调用socket时的操作" class="headerlink" title="调用socket时的操作"></a>调用socket时的操作</h3><ul>
<li>应用程序调用socket申请创建套接字</li>
<li>协议栈分配用于存放一个套接字所需的内存空间</li>
<li>在套接字的内存空间中写入表示这一初始状态的控制信息</li>
<li>将套接字描述符告诉应用程序</li>
</ul>
<h2 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h2><h3 id="连接是什么意思"><a href="#连接是什么意思" class="headerlink" title="连接是什么意思"></a>连接是什么意思</h3><ul>
<li>客户端创建套接字，但不知道通信对象是谁</li>
<li>连接操作 把服务器的IP地址和端口号信息告知客户端协议栈</li>
<li>服务器创建套接字，但协议栈也不知道通信对象是谁，和客户端不同的是，在服务器上，连应用程序也不知道通信对象是谁</li>
<li>连接操作，客户端向服务器告知，我的IP地址是 xxx.xxx. xxx.xxx， 端口号是 yyyy。</li>
<li>连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作</li>
<li>此外，当执行数据收发操作时，还需要一块用来临时存放要收发数据的内存空间，这块内存空间称为缓冲区，也是在连接过程中分配的</li>
</ul>
<h3 id="负责保存控制信息的头部"><a href="#负责保存控制信息的头部" class="headerlink" title="负责保存控制信息的头部"></a>负责保存控制信息的头部</h3><ul>
<li>控制信息分两类：一类是客户端和服务器相互联络时交换的控制信息，这部分记录在头部</li>
<li>另一类是控制协议栈操作的信息，这部分记录在套接字里</li>
</ul>
<h2 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h2><h3 id="将HTTP请求消息交给协议栈"><a href="#将HTTP请求消息交给协议栈" class="headerlink" title="将HTTP请求消息交给协议栈"></a>将HTTP请求消息交给协议栈</h3><ul>
<li>套接字管道建立好之后，应用程序调用write将要发送的数据交给协议栈</li>
<li>协议栈并非一收到数据就马上发送出去，而是将数据存放在内部的发送缓冲区中，并等待应用程序的下一段数据。为了网络效率，数据要积累到一定的量才开始发送</li>
<li>至于积累多少数据，根据两个判断要素</li>
<li>第一 每个网络能容纳的数据长度， MTU(一个网络包的最大长度，以太网中一般为 1500 字节),MSS：除去头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</li>
<li>第二 时间 当应用程序发送数据的频率不高的时候，即便缓冲区的数据长度没达到MSS，也应该果断发送出去，协议栈内部有一个计时器，当经过一定时间之后，就会把网络包发送出去</li>
</ul>
<h3 id="使用ACK号确认网络包已收到"><a href="#使用ACK号确认网络包已收到" class="headerlink" title="使用ACK号确认网络包已收到"></a>使用ACK号确认网络包已收到</h3><ul>
<li>ACK号是接收方给发送方的响应确认，通过这样的方式，发送方就能够确认对方到底收到了多少数据</li>
</ul>
<h1 id="集线器、交换机、路由器"><a href="#集线器、交换机、路由器" class="headerlink" title="集线器、交换机、路由器"></a>集线器、交换机、路由器</h1><h1 id="接入网和网络运营商"><a href="#接入网和网络运营商" class="headerlink" title="接入网和网络运营商"></a>接入网和网络运营商</h1><h1 id="服务器端局域网"><a href="#服务器端局域网" class="headerlink" title="服务器端局域网"></a>服务器端局域网</h1><h1 id="信息旅程"><a href="#信息旅程" class="headerlink" title="信息旅程"></a>信息旅程</h1>]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>getopts命令解析</title>
    <url>/2017/01/16/getopts%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>shell选项设置怎么写</p>
<a id="more"></a>
<p>getopts命令，主要和循环语句一起使用，可以非常简洁的设置命令的选项参数。<br>例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">while getopts &quot;ab:cd:&quot; Option</span><br><span class="line"># b and d take arguments</span><br><span class="line">#</span><br><span class="line">do</span><br><span class="line">	case $Option in</span><br><span class="line">		a) echo -e &quot;a &#x3D; $OPTIND&quot;;;</span><br><span class="line">        b) echo -e &quot;b &#x3D; $OPTIND $OPTARG&quot;;;</span><br><span class="line">        c) echo -e &quot;c &#x3D; $OPTIND&quot;;;</span><br><span class="line">        d) echo -e &quot;d &#x3D; $OPTIND $OPTARG&quot;;;</span><br><span class="line">     esac</span><br><span class="line">done</span><br><span class="line">if [ &quot;$OPTIND&quot; -gt &quot;$#&quot; ] </span><br><span class="line">then </span><br><span class="line">	echo &quot;Missing real parameter!&quot; </span><br><span class="line">	exit 2 </span><br><span class="line">fi</span><br><span class="line">shift $(($OPTIND - 1))</span><br><span class="line">echo $1</span><br></pre></td></tr></table></figure>
<ul>
<li>选项可以用一整个字符串表示，如果选项后面有<code>:</code>，则该选项后面要跟参数</li>
<li>$OPTION表示每次对应的选项</li>
<li>$OPTARG表示选项所对应的参数</li>
<li>比较难理解的是$OPTIND,初始值为1，描述的是下次该使用第几个<code>字段</code>作为选项</li>
</ul>
<p>比如<code>testops -a -b foo -cd bar hello</code>的执行结果是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 2</span><br><span class="line">b &#x3D; 4 foo</span><br><span class="line">c &#x3D; 4</span><br><span class="line">d &#x3D; 6 bar</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<ul>
<li>循环到<code>a</code>时，，下一个选项该使用第二个字段<code>-b</code>, 所以此时$OPTIND为2</li>
<li>循环到<code>b</code>时，，下一个选项该使用第四个字段<code>-cd</code>, 所以此时$OPTIND为4</li>
<li>循环到<code>c</code>时，，下一个选项该使用仍是第二个字段<code>-cd</code>, 所以此时$OPTIND为4 </li>
<li>循环到<code>d</code>时，，下一个选项该使用的，应该是跳过<code>bar</code>的第6个字段（虽然不是选项），此时$OPTIND为6</li>
<li>shift $(($OPTIND - 1))在循环体后很常用，可以将选项和选项参数都shift掉，留下命令的实际参数，让它成为$1</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ &quot;$OPTIND&quot; -gt &quot;$#&quot; ] </span><br><span class="line">then </span><br><span class="line">	echo &quot;Missing real parameter!&quot; </span><br><span class="line">	exit 2 </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<ul>
<li>这段语句写在循环后面，主要用于判定这条命令的有没有实际参数（不是选项的参数）</li>
</ul>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>Mac使用技巧</title>
    <url>/2017/01/11/Mac%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>各个网站总结的Mac高阶使用技巧，主要是针对命令行的</p>
<a id="more"></a>
<h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><h3 id="caffeinate"><a href="#caffeinate" class="headerlink" title="caffeinate"></a>caffeinate</h3><ul>
<li>自带命令，防止系统休眠</li>
<li>直接在命令行中输入<strong>caffeinate</strong>即可</li>
</ul>
<blockquote>
<p>caffeinate</p>
</blockquote>
<ul>
<li>可以设置时间</li>
</ul>
<blockquote>
<p>caffeinate -t 3600(防止系统休眠秒数)</p>
</blockquote>
<ul>
<li>可以设置只要某个程序打开，计算机就不休眠，比如</li>
</ul>
<blockquote>
<p>caffeinate /Applications/BaiduNetdisk_mac.app/Contents/MacOS/BaiduNetdisk_mac （让我的百度网盘下载时，系统不休眠）</p>
</blockquote>
<h3 id="archey"><a href="#archey" class="headerlink" title="archey"></a>archey</h3><ul>
<li>命令行显示系统信息</li>
<li>用<code>brew</code>安装</li>
</ul>
<blockquote>
<p>archey</p>
</blockquote>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="say"><a href="#say" class="headerlink" title="say"></a>say</h3><ul>
<li>让Mac朗读文本</li>
</ul>
<blockquote>
<p>say “hello world”</p>
</blockquote>
<h3 id="查看IP地址"><a href="#查看IP地址" class="headerlink" title="查看IP地址"></a>查看IP地址</h3><ul>
<li><p>ifconfig 查看en0</p>
</li>
<li><p>查看公网IP</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl ip.me</span><br><span class="line">curl curlip.me</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>Mad Men</title>
    <url>/2016/12/08/Mad-Men/</url>
    <content><![CDATA[<p>Mad Men 剧本分析</p>
<a id="more"></a>
<h1 id="Season1"><a href="#Season1" class="headerlink" title="Season1"></a>Season1</h1><h2 id="Episode-1-Smoke-Gets-in-Your-Eyes"><a href="#Episode-1-Smoke-Gets-in-Your-Eyes" class="headerlink" title="Episode 1 Smoke Gets in Your Eyes"></a>Episode 1 Smoke Gets in Your Eyes</h2><ul>
<li>Don在就把里问一个黑人服务员，他为什么喜欢抽另一个牌子的香烟，而不是Lucky Strike, 得到“i love smoking”的回答记在餐巾纸上</li>
<li>Peggy是从乡村来纽约打拼的女孩，司职Don的秘书，第一天工作，在电梯里被男职员们撩。被秘书总管教育要注意形象，而且在Don面前要扮演“妈妈和女侍者”的角色</li>
<li>Peter是公司的初级业务经理，性格傲慢，野心很大，对Peggy出言不逊，但婚前单身派对没钓到女人</li>
<li>Don和犹太女商人Richel会面，两人因为商业观点不和，不欢而散</li>
<li>和Lucky Strike客户见面，Don一筹莫展，Peter插手引用从Don垃圾桶里偷来的点子，却遭到一阵奚落，在客户离开前，Don突然来了灵感，力挽狂澜（It’s toasted）</li>
<li>醉醺醺又失意的Peter晚上出现在Peggy房前</li>
</ul>
<h2 id="Episode-2-Ladies-Room"><a href="#Episode-2-Ladies-Room" class="headerlink" title="Episode 2 Ladies Room"></a>Episode 2 Ladies Room</h2><ul>
<li>从第一集各个角色粉末登场后，这一集刻画了更繁琐的人物关系，主要集中在女性，所有本集取名Ladies Room</li>
<li>剧情主要围绕两个女人进行，一个是初入职场打拼的Peggy，另一个是在第一集末尾出现了一下的Don的老婆Betty</li>
<li>在一次和Roger夫妇的四人晚宴上，Don拒绝回忆自己的过去</li>
<li>去洗手间的时候，Betty发现自己的手不自觉的颤抖，老毛病又犯了。</li>
<li>Betty听说街区又搬来一个新的离婚女人，开车的时候却手不听使唤，撞到路边，Don知情后，建议他去看心理医生</li>
<li>Don在情人Midge那里看到了一台电视，Midge说是朋友送的，搞得Don醋意满满，随性的Midge直接把电视机丢出了窗外</li>
<li>Don在和中层们讨论男人除臭剂的创意，高级合伙人Bert Cooper进来说要接手尼克松竞选的案子，Don虽然兴趣不大，但老板之一让他带队</li>
<li>Peggy还在办公室经历她的菜鸟历程，Joan教给她怎么用自己的姿色拿到免费午餐，Peggy发现办公室所有企图帮助她的男人都想和他有一腿。厌倦了被男人撩的Peggy，打开抽屉，是Peter在尼亚加拉瀑布渡蜜月寄回来的明信片，原来Peggy的心里一直装着Peter</li>
</ul>
<h2 id="Episode-3-Marriage-of-Figaro"><a href="#Episode-3-Marriage-of-Figaro" class="headerlink" title="Episode 3 Marriage of Figaro"></a>Episode 3 Marriage of Figaro</h2><ul>
<li>Peter渡蜜月回来，暗示Peggy，他已经结婚了，之前和她的一夜情还望理解</li>
<li>Don在上班的火车上被一个人叫Dick Whitman（老战友认出了他的真实身份）</li>
<li>Richel作为一个成功的女商人和Don这个有妇之夫，有了火花，但两人鉴于各自的身份都不敢投入太多</li>
<li>本集用半级的篇幅写Don孩子的生日宴会，主要勾勒了美国60年代中产阶级家庭的各个位面，以及Draper夫妇心理以及感情上的博弈。刚开始宴会欢喜异常，但颇有姿色的单身母亲Helen出现后，立刻起了波澜。戏剧编排类似舞台剧，但非常精巧。</li>
</ul>
<h2 id="Episode-4-New-Amstertam"><a href="#Episode-4-New-Amstertam" class="headerlink" title="Episode 4 New Amstertam"></a>Episode 4 New Amstertam</h2><ul>
<li>新阿姆斯特丹是纽约城起初的名字</li>
<li>Peter的妻子想在纽约市区买套大房子，但他俩的钱不够，无奈只能用给双方家长借，但Peter的爸爸讨厌Peter的行业，不愿提供帮助。</li>
<li>Peter背着Don和创意团队，私下向自己的客户越级推销电子，被采纳后，Don大为光火，要让Peter走人，但大老板Bert Cooper却说，Peter的后台很硬</li>
<li>Betty遇到了Helen的前夫，最后了解到Helen的一些事情，Helen说去参加肯尼迪竞选的义务活动，让Betty替她看孩子，Helen的孩子觉得Betty像个公主，这让Betty既不安又欣喜</li>
</ul>
<h2 id="Episode-5-5G"><a href="#Episode-5-5G" class="headerlink" title="Episode 5 5G"></a>Episode 5 5G</h2><ul>
<li>这是设计极为精妙的一集，Don给银行出了开男人小金库（行政账户），最后却把为了不暴露身世，把小金库里的钱都给了自己的同父异母的弟弟</li>
<li>Peggy无意间听到了Don和Midge调情的电话，看到Don因为处理弟弟的事情玩消失，有点慌神，恰逢Betty来办公室照相，Peggy只能出卖秘密，像Joan求助。</li>
<li>Pete得知自己的同事在杂志上发表了小说，心生妒忌，让老婆找关系把自己的小说也发表了，老婆找到自己的初恋男友(出卖色相?)换来的却是在《男孩杂志》上发表的机会</li>
<li>5G是Don的弟弟写信让Don去这个地方找他</li>
</ul>
<h2 id="Episode-6-Babylon"><a href="#Episode-6-Babylon" class="headerlink" title="Episode 6 Babylon"></a>Episode 6 Babylon</h2><ul>
<li>Don摔倒,偶然间看到了童年的自己，弟弟刚出生的回忆</li>
<li>Don躺在床上读书,The Best of Everything/ Rona Jaffe。和妻子一番关于电影和妻子已逝母亲的讨论，妻子表达对Draper的爱与渴望</li>
<li>以色列旅游请公司出谋划策, Exodus</li>
<li>上午，Sterling的老婆来公司探班, Joan表现的毫无瓜葛，但中午就和Sterling出现在酒店，Sterling说考虑离婚。Joan去说要保持现状，先选个合适的人结婚</li>
<li>在办公室讨论以色列的旅游项目，Draper没主意，求助犹太女老板</li>
<li>公司聚集女员工对口红公司的新口红做调查，男员工隔着单向玻璃观察* Don和犹太女老板讨论以色列旅游，女老板告诉他，乌托邦有两个意思，一个是美丽的地方，另一个是，到不了的地方</li>
<li>Peggy的想法初露锋芒，不从一百种口红里选择一种，口红老板盛赞她</li>
<li>犹太女老板打给她妈说遇到了心上人，但不是犹太人，妈妈劝她60年代了，不必再考虑民族，要追随浪漫</li>
<li>Joan通知Peggy,广告老板决定用她的主意</li>
<li>Don 和 Midge 偷情时被中断，Midge 的朋友来邀请她去一个活动。Don 本来不想去的，Midge 偷偷跟他说她会只穿一条裙子（不穿内裤），然后，Don 妥妥的也去了。</li>
<li>Sterling给Joan买了只鸟</li>
<li>Don，Midge和他的革命战友去看革命演出，活动上有人演奏了一曲Babylon，作为本片的片尾曲</li>
<li>犹太人公元前9世纪亡国，被流放到巴比伦，巴比伦是犹太人流亡的起点，所以本级起名叫巴比伦</li>
</ul>
<h2 id="Episode-7-Red-in-the-Face"><a href="#Episode-7-Red-in-the-Face" class="headerlink" title="Episode 7 Red in the Face"></a>Episode 7 Red in the Face</h2><ul>
<li>来自Dr.Wayne（心理医生）关于Betty的鉴定，consume with pretty jealousies and overwhelmed with everyday activities, emotions of childhood, 母亲的死对Betty打击很大</li>
<li>工作日即将结束，Roger趁老婆女儿不在，想和Joan私会，但被Joan拒绝，理由是她要和自己的室友Carol一起度过周末</li>
<li>Roger无趣，约Don去喝酒，然后Don邀请Roger去他家。和Betty相谈甚欢，Roger也错认为Betty对他有意，Don嗅到了异样，警告了Betty，准备报复Roger。（电梯里给服务生数钱，门关上，恰到好处）</li>
<li>Pete想把一个送重了的毫无用处的结婚礼物（一个薯条蘸酱盘）退回商店，处处想用自己的魅力赚取百货商店女员工的芳心，同时占退货的便宜，无奈女员工对他不感兴趣，他只能把礼物换成一把玩具枪，在办公室出尽了洋相</li>
<li>Betty在超市遇到了新搬进街区的寡妇Helen，Helen说自己的儿子偷藏了一缕金色头发，而头发的主人是Betty，并且责怪是Betty给他儿子的，Betty给了Helen一巴掌。</li>
<li>Don最终优雅的摆了Roger一道，下午就见总统竞选项目的客户，中午和Roger一起去大吃特吃牡蛎，Roger胃溃疡犯了，回公司还发现电梯坏了（Don的陷阱），只能爬楼，Roger年迈经不起折腾，爬上去以后，在客户面前出了糗（吐了一地）</li>
<li>Red in the Face 表示愤怒的意思</li>
</ul>
<h2 id="Episode-8-The-Hobo-Code"><a href="#Episode-8-The-Hobo-Code" class="headerlink" title="Episode 8 The Hobo Code"></a>Episode 8 The Hobo Code</h2><ul>
<li>Pete和Peggy趁早上办公室没人，重温旧梦</li>
<li>新来的接线员Lois Sadler爱上了创意部的单身且着装得体的意大利裔艺术总监Sal</li>
<li>唇膏的case，创意部采用了Peggy的想法，起初并不能说服唇膏公司采用几种或一种主打颜色的口红，但Don站起来力挽狂澜，强势要求唇膏公司改变陈旧的商业计划，最后获得成功。</li>
<li>Don意外的从老板Bert那里领到了2500美元的支票</li>
<li>Peggy第一次受到真正的尊重，被叫进办公室一起庆祝，Peggy打算下了班大家一起去庆祝，Joan却心怀嫉妒。</li>
<li>接线员想约Sal一起参加Party，但Sal似乎对女人并不敢兴趣，他是gay，和一个男推销员去约会了。</li>
<li>Peter的老婆突兀的闯进他的办公室，给他送上香槟，让他感觉完全被富家老婆操纵，心情很糟糕，参加Party时，也闷闷不乐。</li>
<li>Don拿着领到的2500美金，想和Midge一起去巴黎，发现Midge在屋里和一帮共产主义战友在屋里吸大麻。Don因为自己的职业被Midge的朋友称作“骗子“,Don予以回击。</li>
<li>吸完大麻的Don产生了幻觉，实则是自己久久不愿触碰的童年回忆，自己贪心的亲生父亲，和严厉的后母，曾经有一个流浪汉乞讨，父亲答应他给自己干一天活就给他一枚银币，但流浪汉干完了一天活，父亲却爽了约, Dick(Don)找到流浪汉留下的私人记号——”骗子“，这也是本集叫做 The Hobo Code 的原因</li>
</ul>
]]></content>
      <categories>
        <category>写作</category>
      </categories>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2016/12/01/Promise/</url>
    <content><![CDATA[<p>ES6里面加的Promise语法，做一个形象的讲解</p>
<a id="more"></a>
<ul>
<li>Promise一篇<a href="https://www.talkingcoder.com/article/6336155176377712832" target="_blank" rel="noopener">非常不错的教程</a></li>
<li>也许是为了简化nodejs里层层叠叠的回调函数，ES6里面加入了一个新的Promise语法，让套娃结构变得美观了许多。</li>
<li>promise，顾名思义，就是“承诺“, 做一个承诺，如果达成了怎么样，如果没达成又怎么样？</li>
<li>下面做一个形象一点的讲解：</li>
</ul>
<ol>
<li><p>先定义一个人类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class People &#123;</span><br><span class="line">  constructor(money)&#123;</span><br><span class="line">    this.money&#x3D;money;</span><br><span class="line">  &#125;</span><br><span class="line">  borrow(b_num)&#123;</span><br><span class="line">    this.money+&#x3D;b_num</span><br><span class="line">  &#125;</span><br><span class="line">  lend(l_num)&#123;</span><br><span class="line">    this.money-&#x3D;l_num</span><br><span class="line">  &#125;</span><br><span class="line">  make()&#123;</span><br><span class="line">    let income &#x3D; 20;</span><br><span class="line">    this.money+&#x3D;income;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>生成两个实例，Bob身无分文，Ann有1000块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Bob &#x3D; new People(0);</span><br><span class="line">const Ann &#x3D; new People(1000)</span><br></pre></td></tr></table></figure></li>
<li><p>现在Bob要向Ann借500块，承诺10天之后，还600块，如果钱不够的话，自愿接受牢狱之灾，他们就签了一份合同, 合同是一个Promise的实例，里面规定，如果10天之后，Bob赚够了600，就执行resolve函数（一个积极的解决方案），如果Bob没赚够，就执行reject函数（一个消极的解决方案）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const contract &#x3D; new Promise(function(resolve,reject)&#123;</span><br><span class="line">  Ann.lend(500);</span><br><span class="line">  Bob.borrow(500);</span><br><span class="line">  let days &#x3D; 10;</span><br><span class="line">  for(let i&#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">    Bob.make()</span><br><span class="line">  &#125;</span><br><span class="line">  if(Bob.money&gt;&#x3D;600)&#123;</span><br><span class="line">      resolve(Bob.money)</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">    reject(Bob.money)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>then()的两个参数是两个函数，分别代表resolve和reject，这里规定，积极的解决方案是Bob把600块还给Ann，而如果Bob没有600块钱，就执行消极的解决方案”Bob进了监狱“</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract.then(function(num)&#123;</span><br><span class="line">  document.write(&#96;Bob的钱:$&#123;num&#125;&#96;);</span><br><span class="line">  Bob.lend(600);</span><br><span class="line">  Ann.borrow(600);</span><br><span class="line">  document.write(&#96;Bob还剩:$&#123;num-600&#125;</span><br><span class="line">      Ann还剩：$&#123;Ann.money&#125;</span><br><span class="line">    &#96;);</span><br><span class="line">&#125;,function(num)&#123;</span><br><span class="line">  document.write(&#96;Bob的钱:+$&#123;num&#125;&#96;);</span><br><span class="line">  document.write(&#96;Bob进了监狱&#96;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里Bob 10天之后挣了700块钱，所以可以把钱还给Ann，免去了牢狱之灾</p>
</li>
</ol>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2016/11/14/Git/</url>
    <content><![CDATA[<p>Git必杀技</p>
<a id="more"></a>

<h1 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h1><ul>
<li><code>global</code>配置文件在 <code>~/.gitconfig</code>里</li>
<li>当前项目的配置文件在 <code>.git/config</code>里</li>
<li>全局配置 <code>git config --global user.name &quot;John Doe&quot;</code></li>
<li>查看配置信息 <code>git config --list</code></li>
</ul>
<h1 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h1><h2 id="git-add-file"><a href="#git-add-file" class="headerlink" title="git add file"></a>git add file</h2><ul>
<li>开始跟踪一个文件</li>
<li>将已经跟踪 并改动的文件放在暂存区 等待提交</li>
</ul>
<h2 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h2><ul>
<li><code>git status</code></li>
</ul>
<h2 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h2><ul>
<li>指定不被跟踪的文件</li>
<li>所有空行或者以注释符号＃ 开头的行都会被Git 忽略。</li>
<li>可以使用标准的glob 模式匹配，即shell命令行用的匹配模式</li>
<li>匹配模式最后跟反斜杠（/）说明要忽略的是目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 此为注释– 将被Git 忽略# 忽略所有.a 结尾的文件*.a# 但lib.a 除外!lib.a# 仅仅忽略项目根目录下的TODO 文件，不包括subdir&#x2F;TODO&#x2F;TODO# 忽略build&#x2F; 目录下的所有文件build&#x2F;# 会忽略doc&#x2F;notes.txt 但不包括doc&#x2F;server&#x2F;arch.txtdoc&#x2F;*.txt# ignore all .txt files in the doc&#x2F; directorydoc&#x2F;**&#x2F;*.txt</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><ul>
<li><code>git diff</code>显示<strong>当前文件</strong>状态和<strong>暂存区文件</strong>状态的差异</li>
<li>如果暂存区是空的（文件提交完毕），则显示当前文件和上次提交的状态差异</li>
<li><code>git diff --staged</code> 显示<strong>暂存区文件</strong>状态和<strong>上次提交</strong>状态的差异</li>
</ul>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><ul>
<li>git commit 会打开默认编辑器输入 <em>**提交信息</em></li>
<li>或者git commit -m “提交信息”</li>
<li>每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或<br>者进行比较</li>
<li>git commit -a 可以Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过git add 步骤</li>
</ul>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ol>
<li>没有被跟踪的文件 直接用rm删除</li>
<li>被跟踪且被提交过的文件， 用<code>git rm file</code>删除，删除的操作会进入暂存区</li>
<li>被跟踪的文件，如果不想被跟踪，用<code>git rm --cache file</code></li>
</ol>
<h2 id="移动和重命名"><a href="#移动和重命名" class="headerlink" title="移动和重命名"></a>移动和重命名</h2><ul>
<li>git rm oldfile newfile</li>
<li>相当于<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mv README.txt README$ git rm README.txt$ git add README</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h2><ul>
<li><code>git log</code></li>
<li>如果显示每次更新的差异 <code>git log -p</code></li>
<li>如果用图形表显示 <code>git log --graph</code></li>
<li>按条件输出日志<ol>
<li>-(n) 仅显示最近的n 条提交</li>
<li>–since=”2008-10-01”, –after 仅显示指定时间之后的提交。</li>
<li>–until, –before 仅显示指定时间之前的提交。</li>
<li>–author=name 仅显示指定作者相关的提交。</li>
<li>你可以给出各种时间格式，比如说具体的某一天（“2008-01-15”），或者是多久以前（“2 years 1 day 3 minutes ago”）。</li>
<li>还可以给出若干搜索条件，列出符合的提交。用–author 选项显示指定作者的提交，用–grep 选项搜索提交说明中的关键字。（请注意，如果要得到同时满足这两个选项搜索条件的提交，就必须用–all-match 选项。否则，满足任意一个条件的提交都会被匹配出来）</li>
</ol>
</li>
</ul>
<h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><h3 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h3><ul>
<li>最后一次提交后，如果文件没有做任何更改，只希望修改一下<strong>提交信息</strong>，<code>git commit --amend</code></li>
<li>如果文件做了更改，需要用这次的更改<em>覆盖</em>上次的提交，先把更改的文件用<code>git add forgotten_file</code>添加到暂存区，然后<code>git commit --amend</code></li>
</ul>
<h3 id="取消已经暂存的文件"><a href="#取消已经暂存的文件" class="headerlink" title="取消已经暂存的文件"></a>取消已经暂存的文件</h3><ul>
<li>推荐方法<code>git reset HEAD 暂存区的file</code>：文件又回到了之前已修改未暂<br>存的状态</li>
<li>简单方法：如果是只是对本次放在暂存区的文件改动不满意，修改文件以后直接git add一下就可以, 新的改动版会覆盖之前暂存区里的文件</li>
<li>暴力方法：直接<code>git rm file --cache</code> 撤销对这个文件的跟踪，把文件改成自己希望的之后，在git add 一次，结果是相同的，但如果撤销完之后需要一次提交，会产生一条delete信息，容易引起误会，所以不推荐</li>
</ul>
<h3 id="取消对文件的修改"><a href="#取消对文件的修改" class="headerlink" title="取消对文件的修改"></a>取消对文件的修改</h3><ul>
<li>如果对此不再想要这一次对文件的修改，想要恢复修改前的状态 <code>git checkout -- 想要恢复的文件</code></li>
<li><strong>注意: 这个操作不可逆</strong></li>
<li>记住，任何已经提交到Git 的都可以被恢复。即便在已经删除的分支中的提交，或者用–amend 重新改写的提交，都可以被恢复。所以，你可能失去的数据，仅限<br>于没有提交过的，对Git 来说它们就像从未存在过一样</li>
</ul>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><ul>
<li><code>git remote</code> 显示远程仓库的名称</li>
<li><code>git remote -v</code> 显示远程仓库的名称和地址</li>
</ul>
<h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><ul>
<li><code>git remote add remote-name address</code></li>
</ul>
<h3 id="从远程仓库抓取数据"><a href="#从远程仓库抓取数据" class="headerlink" title="从远程仓库抓取数据"></a>从远程仓库抓取数据</h3><ul>
<li><code>git fetch remote-name</code></li>
</ul>
<h3 id="推送数据到远程仓库"><a href="#推送数据到远程仓库" class="headerlink" title="推送数据到远程仓库"></a>推送数据到远程仓库</h3><ul>
<li><code>git push remote-name branch-name</code></li>
</ul>
<h3 id="查看远程仓库信息"><a href="#查看远程仓库信息" class="headerlink" title="查看远程仓库信息"></a>查看远程仓库信息</h3><ul>
<li><code>git remote show remote-name</code></li>
</ul>
<h3 id="远程仓库的删除和重命名"><a href="#远程仓库的删除和重命名" class="headerlink" title="远程仓库的删除和重命名"></a>远程仓库的删除和重命名</h3><ul>
<li><code>git remote rename oldname newname</code>重命名</li>
<li><code>git remote rm remote-name</code> 删除</li>
</ul>
<h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><ul>
<li>标签主要是用来在某次提交后，给文件打个记号，注明版本号，方便版本管理和查找<h3 id="查看已有标签"><a href="#查看已有标签" class="headerlink" title="查看已有标签"></a>查看已有标签</h3></li>
<li><code>git tag</code></li>
</ul>
<h3 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h3><ul>
<li>添加轻标签（只有版本号，没有注释，<code>git tag 版本号</code></li>
<li>添加含注释的标签， <code>git tag -a（annotated） 版本号 -m &#39;标注信息&#39;</code></li>
</ul>
<h3 id="显示标签详情"><a href="#显示标签详情" class="headerlink" title="显示标签详情"></a>显示标签详情</h3><ul>
<li><code>git show 版本号</code> 可以查看对应版本的详情，在哪次提交之后打的tag</li>
</ul>
<h3 id="后期加注标签"><a href="#后期加注标签" class="headerlink" title="后期加注标签"></a>后期加注标签</h3><ul>
<li><code>git tag -a v1.2 9fceb02</code> 这样就可以在对应的提交之后加一个v1.2的标签</li>
</ul>
<h3 id="分享标签"><a href="#分享标签" class="headerlink" title="分享标签"></a>分享标签</h3><ul>
<li>默认情况下，git push 并不会把标签传送到远端服务器上</li>
<li>需要用单独命令<code>git push remote-name v1.2</code></li>
<li>如果要一次推送本地所有标签 <code>git push remote-name --tags</code></li>
</ul>
<h2 id="技巧和窍门"><a href="#技巧和窍门" class="headerlink" title="技巧和窍门"></a>技巧和窍门</h2><ul>
<li>连按2次<code>TAB</code>，可以选择自动补全的内容</li>
<li>可以给git命令应用别名<code>git config --global alias.unstage &#39;reset HEAD --&#39;</code></li>
<li>这样就可以<code>git unstage fileA</code></li>
</ul>
<h1 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h1><h2 id="新建-切换分支"><a href="#新建-切换分支" class="headerlink" title="新建 切换分支"></a>新建 切换分支</h2><ul>
<li><code>git branch branch-name</code> 新建一个分支</li>
<li><code>git checkout branch-name</code> 切换到一个分支上去</li>
<li><code>git checkout -b branch-name</code> 新建一个分支 并直接切换过去</li>
</ul>
<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><ul>
<li><code>git merge branch-name</code> 把brach-name指向的分支合并到当前分支下</li>
</ul>
<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><ul>
<li><code>git branch -d brachname</code> </li>
<li>删除分支可用于放弃某个分支，或者合并分支后，把没用的分支舍弃掉</li>
</ul>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><ul>
<li><code>git branch</code>可以查看工作目录的所有分支，和当前所在分支</li>
<li><code>git branch -v</code> 可以查看所有分支和他们的最后一次提交</li>
<li><code>git branch --merged</code> 可以查看已经合并的分支</li>
<li><code>git branch --no-merged</code> 可以查看没有合并的分支</li>
</ul>
<h2 id="利用分支进行开发的工作流程"><a href="#利用分支进行开发的工作流程" class="headerlink" title="利用分支进行开发的工作流程"></a>利用分支进行开发的工作流程</h2><h3 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h3><p><img src="http://7xthfw.com1.z0.glb.clouddn.com/long_term_branch.png" alt="长期分支"></p>
<ul>
<li>master分支主要用来提交已经稳定的版本</li>
<li>开发工作的主要分支为develop分支，在develop分支分发出许多小业务，并逐渐合并到develop分支</li>
<li>一旦develop分支更新到一个稳定的版本，就可以合并到master分支里</li>
<li>topic表示特性分支，可以用于实验或者开发某些独特的性能</li>
</ul>
<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><ul>
<li>远程分支的问题比较难理解，通过一个例子讲清楚</li>
</ul>
<ol>
<li>假设团队有个地址为git.ourcompany.com 的Git 服务器，上面有一些项目开发之前公用的lib</li>
<li>你用git clone的方式把服务器上的东西抓取到本地</li>
<li>这时候你的文件家里有两个指针，一个指向本地的master分支，另一个指向远程的origin/master分支, 只是项目刚开始，两个分支指向同一个地方</li>
<li>随着本地项目的进行和提交（还未push数据到远程），master分支在前进，origin/master指针还停留在原地（假设还没有其他人更新远程服务器）</li>
<li>可以用<code>git log origin/master</code>，查看远程的提交</li>
<li>可以用<code>git log -p master..origin/master</code>或者<code>git diff master origin/master</code>查看两个分支的区别</li>
</ol>
<h3 id="git-fetch-和-git-pull的区别"><a href="#git-fetch-和-git-pull的区别" class="headerlink" title="git fetch 和 git pull的区别"></a>git fetch 和 git pull的区别</h3><ul>
<li><code>git fetch [remote-name] [branch-name]</code> 可以将某个远程服务器的某个分支的数据抓取到本地，但先不对这些数据进行任何操作</li>
<li>选择这些数据用<code>remote-name/branch-name</code>进行操作</li>
<li>如果要比较本地master分支与远程navbar服务器reverse-color分支的内容，可以用<code>git diff navbar/reverse-color master</code></li>
<li>如果要合并他们就用<code>git merge navbar/reverse-color</code></li>
<li>而<code>git pull [remote-name] [branch-name]</code>则直接先执行git fetch，再执行git merge</li>
<li>在实际使用中，git fetch更安全一些。因为在merge前，我们可以查看更新情况，然后再决定是否合并</li>
</ul>
<h3 id="跟踪远程分支"><a href="#跟踪远程分支" class="headerlink" title="跟踪远程分支"></a>跟踪远程分支</h3><ul>
<li><code>git checkout --track navbar/reverse-color</code> 本地会建一个reverse-color分支跟踪远程分支 </li>
<li>这样用<code>git pull</code>或者<code>git push</code> 本地reverse-color分支就会自动和远程reverse-color分支进行关联</li>
<li>如果要自定义本地分支的名字，就用<code>git checkout -b color_dark navbar/reverse-color</code></li>
</ul>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><ul>
<li><code>git push 远程名 :分支名</code></li>
</ul>
<h2 id="分支的衍合rebase"><a href="#分支的衍合rebase" class="headerlink" title="分支的衍合rebase"></a>分支的衍合rebase</h2><ul>
<li>把某个单独开发的分支<strong>挤压</strong>（而不是merge的合并）到主分支上来<code>git rebase [主分支] [特性分支]</code></li>
<li><code>git rebase --onto master server client</code> 避开server分支，直接把client分支挤压到master分支上</li>
<li>按 git 的逻辑， pull 回来的变更能fast-forward过去的时候就应该 rebase 。而有冲突的时候，merge 能如实反映工作的起点和每一个合并点，但是容易形成复杂的版本树；rebase 相当于不断移动分支工作的起点，并且这个移动的过程在版本历史里是不可见的，所以版本线清爽。</li>
<li>一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。所以，一个人工作，私有分支，本地内容，用rebase。多人协作，公开分支，公开内容，用merge</li>
</ul>
<h1 id="Git工作规范"><a href="#Git工作规范" class="headerlink" title="Git工作规范"></a>Git工作规范</h1><h2 id="提交-1"><a href="#提交-1" class="headerlink" title="提交"></a>提交</h2><ul>
<li><p>git add之前，先git diff 看看本次的修改，有没有空白行(git 会标注出来)</p>
</li>
<li><p>每次提交应该限定完成一次逻辑功能，尽可能多分解成小的提交，便于别人理解，如果一次完成了很多工作，忘记提交了，可以用git add –patch处理</p>
</li>
<li><p>提交说明 参照git://git.kernel.org/pub/scm/git/git.git里的</p>
</li>
</ul>
<h1 id="Git工具"><a href="#Git工具" class="headerlink" title="Git工具"></a>Git工具</h1><h2 id="查看引用日志"><a href="#查看引用日志" class="headerlink" title="查看引用日志"></a>查看引用日志</h2><ul>
<li>采用git对工作目录进行操作，都会被记录下来，用git log只能看到提交操作，其他操作（切换分支，merge之类）都用<code>git reflog</code>查看，这个日志叫做引用日志</li>
<li>引用日志只存在于本地</li>
</ul>
<h2 id="祖先引用"><a href="#祖先引用" class="headerlink" title="祖先引用"></a>祖先引用</h2><ul>
<li>用指针（HEAD）定位commit的位置, <code>HEAD^</code>指针的上一个提交，<code>HEAD^^</code>指针的上上个提交，</li>
<li><code>HEAD^</code>还可以用<code>HEAD~</code>表示，但后者后面跟的是具体数字，例如<code>HEAD^^</code>等价于<code>HEAD~2</code>,<code>HEAD^^^</code>等价于<code>HEAD~3</code></li>
</ul>
<h2 id="双点定位"><a href="#双点定位" class="headerlink" title="双点定位"></a>双点定位</h2><ul>
<li><code>git log master..experiment</code>这句话的意思是“所有可从 experiment 分支中获得而不能从 master 分 支中获得的提交</li>
<li>比较常用的是<code>git log origin/master..HEAD</code> 显示任何在你当前分支上而不在远程 origin 上的提交。如果你运行 git push 并且的你 的当前分支正在跟踪 origin/master， 被 git log origin/master..HEAD 列出的提交就是将被传输到服务器上的提交</li>
<li><code>git log refA..refB</code>的等价写法<code>git log ^refA refB</code>，<code>git log refB --not refA</code> 后两个的语法也适合多点定位，例如<code>git log refA refB ^refC</code>,<code>git log refA refB --not refC</code></li>
</ul>
<h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><ul>
<li>如果在一个分支下的工作还没有达到提交的标准，这时候必须跳转到另一个分支完成工作，需要将现有的暂存起来</li>
<li><code>git stash</code>会将现有的工作往堆栈推送一个贮藏</li>
<li>用<code>git stash list</code>可以查看所有的贮藏</li>
<li><code>git stash apply</code>可以将最近一次的贮藏调会工作目录，<code>git stash apply stash@{n}</code>可以调回更早的贮藏</li>
<li>也可以在其他分支调用贮藏</li>
<li>如果想移除某个贮藏 就要用<code>git stash drop stash@{n}</code></li>
<li>从贮藏去恢复过来的文件，默认都回到了不暂存区，如果贮藏之前有暂存的文件，想要恢复之前‘暂存的归暂存，不暂存的归不暂存’，就要用<code>git stash --index</code></li>
<li><code>git stash pop</code> 来重新应用储藏，同时立刻将其从堆栈中移走。</li>
</ul>
<h2 id="重写历史"><a href="#重写历史" class="headerlink" title="重写历史"></a>重写历史</h2><h3 id="改变最近一次提交"><a href="#改变最近一次提交" class="headerlink" title="改变最近一次提交"></a>改变最近一次提交</h3><ul>
<li><code>git commit --amend</code> 会修改提交说明，重新提交一次，如果暂存区有新的内容，也会被一起提交</li>
</ul>
<h3 id="改变更早的提交"><a href="#改变更早的提交" class="headerlink" title="改变更早的提交"></a>改变更早的提交</h3><ul>
<li>如果要修改更早的提交记录就要用<code>git rebase -i HEAD~n</code></li>
<li>n表示从最后的提交往前数多少条记录，把想改的记录<code>pick</code>改成<code>edit</code>然后退出，按照要求操作</li>
</ul>
<h3 id="压制提交"><a href="#压制提交" class="headerlink" title="压制提交"></a>压制提交</h3><ul>
<li>开始和改变更早的提交相同</li>
<li>然后把<code>pick</code>改成<code>squash</code></li>
</ul>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>Vuejs2.0框架研究</title>
    <url>/2016/11/10/Vuejs2-0%E6%A1%86%E6%9E%B6%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<p>VUEJS</p>
<a id="more"></a>
<p><strong>注明：因为hexo语法解析的原因，本文中所有的<code>{{}}</code>都用<code>[[]]</code>代替</strong></p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="挂载元素"><a href="#挂载元素" class="headerlink" title="挂载元素"></a>挂载元素</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sayHi &#x3D; new Vue (&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    dialogue: &quot;hello&quot;,</span><br><span class="line">    title: &quot;hhd&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>vuejs将DOM元素挂载到一个VUE实例sayHi上，sayHi成为一个全局对象，可以对其进行各种操作</li>
<li>el指定了挂载点</li>
<li>data里面定义的各个属性，变成了sayHi的属性</li>
</ul>
<h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-2&quot;&gt;</span><br><span class="line">  &lt;span v-bind:title&#x3D;&quot;message&quot;&gt;</span><br><span class="line">    Hover your mouse over me for a few seconds to see my dynamically bound title!</span><br><span class="line">  &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>v-</code>表示用vuejs提供的attributes</li>
<li><code>v-bind:title=&quot;message&quot;</code> 表示将实例的属性(property)message绑定到span元素的title属性(attribute)上</li>
</ul>
<h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-3&quot;&gt;</span><br><span class="line">  &lt;p v-if&#x3D;&quot;seen&quot;&gt;Now you see me&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>v-if</code>定义一个元素是否可见</li>
<li>seen的值如果是false，该元素就不可见</li>
</ul>
<h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-4&quot;&gt;</span><br><span class="line">  &lt;ol&gt;</span><br><span class="line">    &lt;li v-for&#x3D;&quot;todo in todos&quot;&gt;</span><br><span class="line">      [[ todo.text ]]</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">  &lt;&#x2F;ol&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var app4 &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#app-4&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; text: &#39;Learn JavaScript&#39; &#125;,</span><br><span class="line">      &#123; text: &#39;Learn Vue&#39; &#125;,</span><br><span class="line">      &#123; text: &#39;Build something awesome&#39; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>这个例子和angularjs很像，主要用于遍历元素</li>
</ul>
<h2 id="绑定时间v-on"><a href="#绑定时间v-on" class="headerlink" title="绑定时间v-on:"></a>绑定时间v-on:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-5&quot;&gt;</span><br><span class="line">  &lt;p&gt;[[ message ]]&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;button v-on:click&#x3D;&quot;reverseMessage&quot;&gt;Reverse Message&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var app5 &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#app-5&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#39;Hello Vue.js!&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    reverseMessage: function () &#123;</span><br><span class="line">      this.message &#x3D; this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>v-on:事件类型=“函数名”</li>
<li>函数放在methods里定义</li>
</ul>
<h2 id="数据双向绑定-v-model"><a href="#数据双向绑定-v-model" class="headerlink" title="数据双向绑定 v-model"></a>数据双向绑定 v-model</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-6&quot;&gt;</span><br><span class="line">  &lt;p&gt;[[ message ]]&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;input v-model&#x3D;&quot;message&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var app6 &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#app-6&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#39;Hello Vue!&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>v-model</code>可以实现数据的双向绑定</li>
<li>在页面中修改input的值，message的值会随之变化</li>
<li>反之，修改message的值，input里的值也会变化</li>
</ul>
<h2 id="组件初探"><a href="#组件初探" class="headerlink" title="组件初探"></a>组件初探</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app-7&quot;&gt;</span><br><span class="line">  &lt;ol&gt;</span><br><span class="line">    &lt;!-- Now we provide each todo-item with the todo object    --&gt;</span><br><span class="line">    &lt;!-- it&#39;s representing, so that its content can be dynamic --&gt;</span><br><span class="line">    &lt;todo-item v-for&#x3D;&quot;item in groceryList&quot; v-bind:todo&#x3D;&quot;item&quot;&gt;&lt;&#x2F;todo-item&gt;</span><br><span class="line">  &lt;&#x2F;ol&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&#39;todo-item&#39;, &#123;</span><br><span class="line">  props: [&#39;todo&#39;],</span><br><span class="line">  template: &#39;&lt;li&gt;[[ todo.text ]]&lt;&#x2F;li&gt;&#39;</span><br><span class="line">&#125;)</span><br><span class="line">var app7 &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#app-7&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    groceryList: [</span><br><span class="line">      &#123; text: &#39;Vegetables&#39; &#125;,</span><br><span class="line">      &#123; text: &#39;Cheese&#39; &#125;,</span><br><span class="line">      &#123; text: &#39;Whatever else humans are supposed to eat&#39; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h1><h2 id="生成实例"><a href="#生成实例" class="headerlink" title="生成实例"></a>生成实例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h2><ul>
<li>Vue实例有一些自带的属性和方法，比如data，el,watch，如果要访问他们，前面要加<code>$</code></li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="http://7xthfw.com1.z0.glb.clouddn.com/lifecycle.png" alt="lifecycle"></p>
<h1 id="template语法"><a href="#template语法" class="headerlink" title="template语法"></a>template语法</h1><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><ul>
<li>最基本的数据绑定是用<code>[[]]</code>Mustache 插入数据</li>
<li><code>&lt;span v-once&gt;This will never change: [[ msg ]]&lt;/span&gt;</code>  <code>v-once</code>表示只生成一次数据，数据不能被更新</li>
</ul>
<h2 id="标签内"><a href="#标签内" class="headerlink" title="标签内"></a>标签内</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button v-bind:disabled&#x3D;&quot;someDynamicCondition&quot;&gt;Button&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>HTML标签内不能用Mustache绑定数据，需要用v-bind：进行数据绑定<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[ number + 1 ]]</span><br><span class="line">[[ ok ? &#39;YES&#39; : &#39;NO&#39; ]]</span><br><span class="line">[[ message.split(&#39;&#39;).reverse().join(&#39;&#39;) ]]</span><br><span class="line">&lt;div v-bind:id&#x3D;&quot;&#39;list-&#39; + id&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>
<li>Mustache里还能使用js表达式</li>
<li>标签内通过v-bind:也能使用表达式</li>
</ul>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[ message | capitalize ]]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  filters: &#123;</span><br><span class="line">    capitalize: function (value) &#123;</span><br><span class="line">      if (!value) return &#39;&#39;</span><br><span class="line">      value &#x3D; value.toString()</span><br><span class="line">      return value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>Mustache内部还能通过<code>|</code>将数据重定向给一个函数</li>
<li>函数是一个过滤器，在生成实例的时候指定</li>
</ul>
<h2 id="缩略用法"><a href="#缩略用法" class="headerlink" title="缩略用法"></a>缩略用法</h2><ul>
<li><code>v-bind:url</code> 可以缩略为<code>:url</code></li>
<li><code>v-on:click</code> 可以缩略为<code>@click</code></li>
</ul>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="v-on-监听事件"><a href="#v-on-监听事件" class="headerlink" title="v-on:监听事件"></a>v-on:监听事件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example-1&quot;&gt;</span><br><span class="line">  &lt;button v-on:click&#x3D;&quot;counter +&#x3D; 1&quot;&gt;Add 1&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;p&gt;The button above has been clicked [[ counter ]] times.&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var example1 &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#example-1&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    counter: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="事件在method中指定"><a href="#事件在method中指定" class="headerlink" title="事件在method中指定"></a>事件在method中指定</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button v-on:click&#x3D;&quot;warn(&#39;Form cannot be submitted yet.&#39;, $event)&quot;&gt;Submit&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  warn: function (message, event) &#123;</span><br><span class="line">    &#x2F;&#x2F; now we have access to the native event</span><br><span class="line">    if (event) event.preventDefault()</span><br><span class="line">    alert(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><h2 id="输入框"><a href="#输入框" class="headerlink" title="输入框"></a>输入框</h2><h3 id="单行输入框"><a href="#单行输入框" class="headerlink" title="单行输入框"></a>单行输入框</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input v-model&#x3D;&quot;message&quot; placeholder&#x3D;&quot;edit me&quot;&gt;</span><br><span class="line">&lt;p&gt;Message is: [[ message ]]&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<h3 id="多行输入框"><a href="#多行输入框" class="headerlink" title="多行输入框"></a>多行输入框</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;Multiline message is:&lt;&#x2F;span&gt;</span><br><span class="line">&lt;p style&#x3D;&quot;white-space: pre&quot;&gt;[[ message ]]&lt;&#x2F;p&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;textarea v-model&#x3D;&quot;message&quot; placeholder&#x3D;&quot;add multiple lines&quot;&gt;&lt;&#x2F;textarea&gt;</span><br></pre></td></tr></table></figure>

<h2 id="checkbox"><a href="#checkbox" class="headerlink" title="checkbox"></a>checkbox</h2><h3 id="布尔值的checkbox"><a href="#布尔值的checkbox" class="headerlink" title="布尔值的checkbox"></a>布尔值的checkbox</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;checked&quot;&gt;</span><br><span class="line">&lt;label for&#x3D;&quot;checkbox&quot;&gt;[[ checked ]]&lt;&#x2F;label&gt;</span><br></pre></td></tr></table></figure>

<h3 id="其他值的checkbox"><a href="#其他值的checkbox" class="headerlink" title="其他值的checkbox"></a>其他值的checkbox</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;jack&quot; value&#x3D;&quot;Jack&quot; v-model&#x3D;&quot;checkedNames&quot;&gt;</span><br><span class="line">&lt;label for&#x3D;&quot;jack&quot;&gt;Jack&lt;&#x2F;label&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;john&quot; value&#x3D;&quot;John&quot; v-model&#x3D;&quot;checkedNames&quot;&gt;</span><br><span class="line">&lt;label for&#x3D;&quot;john&quot;&gt;John&lt;&#x2F;label&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;mike&quot; value&#x3D;&quot;Mike&quot; v-model&#x3D;&quot;checkedNames&quot;&gt;</span><br><span class="line">&lt;label for&#x3D;&quot;mike&quot;&gt;Mike&lt;&#x2F;label&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;span&gt;Checked names: [[ checkedNames ]]&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>

<h2 id="radio"><a href="#radio" class="headerlink" title="radio"></a>radio</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;one&quot; value&#x3D;&quot;One&quot; v-model&#x3D;&quot;picked&quot;&gt;</span><br><span class="line">&lt;label for&#x3D;&quot;one&quot;&gt;One&lt;&#x2F;label&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;two&quot; value&#x3D;&quot;Two&quot; v-model&#x3D;&quot;picked&quot;&gt;</span><br><span class="line">&lt;label for&#x3D;&quot;two&quot;&gt;Two&lt;&#x2F;label&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;span&gt;Picked: [[ picked ]]&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>

<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select v-model&#x3D;&quot;selected&quot;&gt;</span><br><span class="line">  &lt;option v-for&#x3D;&quot;option in options&quot; v-bind:value&#x3D;&quot;option.value&quot;&gt;</span><br><span class="line">    [[ option.text ]]</span><br><span class="line">  &lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line">&lt;span&gt;Selected: [[ selected ]]&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;...&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: &#39;A&#39;,</span><br><span class="line">    options: [</span><br><span class="line">      &#123; text: &#39;One&#39;, value: &#39;A&#39; &#125;,</span><br><span class="line">      &#123; text: &#39;Two&#39;, value: &#39;B&#39; &#125;,</span><br><span class="line">      &#123; text: &#39;Three&#39;, value: &#39;C&#39; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="定义组件"><a href="#定义组件" class="headerlink" title="定义组件"></a>定义组件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&quot;tagName&quot;,options)</span><br></pre></td></tr></table></figure>

<h2 id="组件的data"><a href="#组件的data" class="headerlink" title="组件的data"></a>组件的data</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&#39;simple-counter&#39;, &#123;</span><br><span class="line">  template: &#39;&lt;button v-on:click&#x3D;&quot;counter +&#x3D; 1&quot;&gt;[[ counter ]]&lt;&#x2F;button&gt;&#39;,</span><br><span class="line">  &#x2F;&#x2F; data is technically a function, so Vue won&#39;t</span><br><span class="line">  &#x2F;&#x2F; complain, but we return the same object</span><br><span class="line">  &#x2F;&#x2F; reference for each component instance</span><br><span class="line">  data: function () &#123;</span><br><span class="line">  	return &#123;</span><br><span class="line">    	counter: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#example-2&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>组件内部使用数据，要用data属性定义一个函数，返回数据</li>
<li>这样每个组件就有单独的作用域，而并非全局作用域</li>
</ul>
<h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&#39;child&#39;, &#123;</span><br><span class="line">  &#x2F;&#x2F; camelCase in JavaScript</span><br><span class="line">  props: [&#39;myMessage&#39;],</span><br><span class="line">  template: &#39;&lt;span&gt;[[ myMessage ]]&lt;&#x2F;span&gt;&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- kebab-case in HTML --&gt;</span><br><span class="line">&lt;child my-message&#x3D;&quot;hello!&quot;&gt;&lt;&#x2F;child&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>组件的属性要用props声明，在HTML里赋值</li>
<li>如果赋值不是字符串，而是变量或语句，应该用v-bind:props</li>
<li>在js中声明用camelCase写法，因为html不识别这种写法，所哟在html中，应该改为kebab-case</li>
</ul>
<h2 id="event"><a href="#event" class="headerlink" title="event"></a>event</h2><ul>
<li>$on</li>
<li>$emit</li>
</ul>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>CSS动画</title>
    <url>/2016/11/10/CSS%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>对CSS动画一些简要的复习</p>
<a id="more"></a>

<h1 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h1><ul>
<li><p>transition属性必须加给触发前的元素</p>
</li>
<li><p>transition属性各个值为：</p>
<ol>
<li>transition-property</li>
<li>transition-duration</li>
<li>transition-timing-funtion(ease in,ease out)</li>
<li>transition-delay</li>
</ol>
</li>
<li><p>如果是多属性过渡，而且过渡效果各不相同，属性的各个值就应该分开写</p>
</li>
</ul>
<h1 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h1><h2 id="2D"><a href="#2D" class="headerlink" title="2D"></a>2D</h2><ul>
<li>表示元素本身的变换</li>
<li>transform-origin 表示元素变化的原点</li>
<li>元素旋转：transform: rotate(??deg)</li>
<li>元素位移：transform: translate(X,Y)</li>
<li>元素变大变小： transform: scale(宽缩放比，长缩放比)</li>
<li>元素斜切： transform: skew(水平斜切度数，垂直斜切度数)</li>
</ul>
<h2 id="3D"><a href="#3D" class="headerlink" title="3D"></a>3D</h2><ul>
<li>transform: perspective(value)</li>
<li>value越小透视感越强，value越大，透视感越弱</li>
<li>整体变换 可以给容器定义perspective 内容定义变换，例如<br>  .container {<pre><code>perspective: 600px;</code></pre>  }<br>  .item {<pre><code>transform: rotateX(45deg)</code></pre>  }</li>
</ul>
<h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><ul>
<li>animation之后的属性依次是<ol>
<li>animation-name</li>
<li>animation-timing-function</li>
<li>animation-duration</li>
<li>animation-iteration-count: num or infinite</li>
<li>animation-direction: normal, reverse or alternate</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
      </categories>
  </entry>
  <entry>
    <title>北欧神话ABC</title>
    <url>/2016/10/19/%E5%8C%97%E6%AC%A7%E7%A5%9E%E8%AF%9DABC/</url>
    <content><![CDATA[<p>故事原型训练</p>
<a id="more"></a>
<h1 id="典籍"><a href="#典籍" class="headerlink" title="典籍"></a>典籍</h1><ul>
<li><p>《大埃达》是保存北欧神话的最重要的古籍。光明神巴尔德（Balder）的故事、史基尔尼尔（Skirnir）旅行的故事、托尔（Thor）的雷锤的故事，都在《大埃达》中。而尤为重要者，是关于尼伯龙格（Nibelung）故事的十二首诗；著名的日耳曼诗歌《尼伯龙根之歌》（Nibelungenlied）就是脱胎于此。
　</p>
</li>
<li><p>在《大埃达》之外，还有《小埃达》（Younger Edda），因是散文所著，故亦称《散文埃达》（Prose Edda），也是身世不明的古籍</p>
</li>
<li><p>《埃达》因出于基督徒之辑述，故其中颇多既非北欧的也非日耳曼的气氛。而有着纯正北欧风格的，乃是北欧的史诗，萨迦（Saga，传说）。</p>
</li>
<li><p>北欧的原始人，在他们最初注视着自然现象的时候，就已经注意到了两种截然相反然而又同样吸引他们注意的现象：一方面是巨伟粗朴的冰川、惨淡的阳光、北极光的耀亮、常是在发怒似的粗恶的海，雪堆似的巨浪打击着高耸的崖石和冰山；而另一方面呢，是那个短促的夏季的蓝天和碧海、长在的光明，和几乎可说是奇迹的、植物的荣茂。寒冷和温暖的对比是这样强烈，无怪乎原始的冰岛人会设想这个宇宙是火与冰混合着而造成的了</p>
</li>
</ul>
<h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><ul>
<li><p>宇宙起源之始，在广漠太空的中央，有一个极大的无底鸿沟金恩加格（Ginnungagap），被永在的微光包围</p>
</li>
<li><p>鸿沟北方是浓雾与黑暗之国尼弗尔海姆（Niflheim）</p>
</li>
<li><p>此中又有不竭之泉源赫瓦格密尔（Hvergelmir），仿佛是一口煮沸的大锅，向十二道名为埃利伐加尔（Elivagar）的大川供给水源。【埃利伐加尔诸河中最大的一条叫维穆尔（Vimur）】</p>
</li>
<li><p>鸿沟之南，正对着尼弗尔海姆的，乃是真火之国穆斯帕尔海姆（Muspelheim），火焰巨人苏尔特尔（Surtur）镇守于此。这位巨人常以他的发光冒火星的大剑砍击那些滚到无底洞中的冰山，发出擦擦的巨响，而且使那些冰山受热溶化了一半。溶冰所冒出的水汽向上升腾，复为那四周的冷气所袭，凝而为寒霜，越积越多，终于填满了广漠太空的中央。</p>
</li>
<li><p>这样，由于冷与热的不断工作，或竟由于那不可见亦不知所以来的「力」——所谓“万物之主宰”的意志，一个庞大无比的巨人，名为伊密尔（Ymir），或名奥尔格尔密尔（Orgelmir），就从无底鸿沟周围的冰山中生出来了。因为他是从寒霜中产生的，故亦称为霜巨人（Hrimthurs）。这实为冰冻的海洋之人格化。</p>
</li>
<li><p>一头名为奥德姆拉（Audhumla）的大母牛。它的**喷出四股极粗的乳汁，供给了伊密尔的食粮。母牛转而求食物于身边的冰山，以它的粗舌舔冰上的盐，久而久之，冰山渐消而一巨大头颅的头发露出来了，后来连头连身体都出来了；这就是祖神勃利（Buri，产生者） </p>
</li>
<li><p>勃利之子勃尔以女巨人贝丝特拉（Bestla，她是巨人波尔斯隆(Bolthron，恶之刺)的女儿）为妻，生了三个儿子：奥丁（Odin）、维利（Vili）、伟（Ve），——象征着精神、意志和神圣。儿子和父亲一起对抗巨人</p>
</li>
<li><p>神和巨人的战争 霜巨人伊密尔（Ymir）被杀死</p>
</li>
<li><p>当伊密尔死的时候，从他的伤口里涌出大量的血，变成一股洪流，将他自己的一族全部淹死，只剩下勃尔格尔密尔和他的妻子乘舟逃走。他逃到世界的边缘，定居下来，将其地命名为尤腾海姆（Jotunheim，巨人之国），又生了一大群霜巨人，时时想闯到诸神统治的世界中作恶。</p>
</li>
<li><p>战胜了巨人的诸神，于是成了世界之主宰。他们自称为亚萨神族（Aesir，意即世界的柱石与支持者），并且也有时间来做建设的工作了。他们要在这荒凉的太空中创造一个可居住的世界。</p>
</li>
<li><p>诸神将伊密尔的遗体改造成世界，又将四个壮健的矮人命名为诺德里（Nordri，北）、苏德里（Sudri，南）、奥斯特里（Austri，东）、威斯特里（Westri，西），使立于地之四隅，以肩承天。</p>
</li>
<li><p>诸神又从穆斯帕尔海姆取了火来，布满在天穹上，那就是群星。最大的火块留作创造太阳和月亮。诸神找了两匹马，阿尔瓦克（Arvakr，早醒者）和阿尔斯维（Alsvin，快步者），拖那个盛着太阳的金车。盛月亮的车子由一匹名为亚斯维德尔（Alsvider，永远迅速者）的马驾着</p>
</li>
<li><p>驾这太阳和月亮的车，须得两位驭者；诸神看中了巨人蒙迪尔法利（Mundilfari）的一对美丽的孩子：男的名叫玛尼（Mani，月亮），女的名叫苏尔（Sol，太阳）；苏尔是格劳尔（Glaur）的妻子，格劳尔或被称为火焰巨人苏尔特尔的一个儿子。诸神把这两个人弄到天上，使玛尼驾了月车，苏尔驾了日车。</p>
</li>
<li><p>当诸神忙着创造天地、装饰天地的时候，有一大群像蛆一样的东西从伊密尔的肉里生出来了。这些小家伙引起了诸神的注意，诸神乃给它们以形状和人的智慧，并将它们分为两种：</p>
<ul>
<li><p>黑皮肤、诡诈狡猾的，诸神逐之于地下的斯瓦塔尔法海姆（Svartalfaheim，侏儒之国），禁止他们白天到地面上来，如果违反了，就要变成石头。这些家伙被称为Dwarf（矮人）、Gnome（侏儒）、Troll（魔怪）、或Kobold（小鬼），他们的任务是搜集地下秘藏的宝物。找到之后，他们把金银宝石都藏在隐秘的地方，不让人们随便找到</p>
</li>
<li><p>另外一种则是长得白皙、性格温和的，诸神称之为Fairy（仙子）或Elf（精灵），送他们住在空中的亚尔夫海姆（Alfheim，精灵之国），他们可以随意飞来飞去，照料花草，和鸟雀蝴蝶游戏，或是在月夜的草地上跳舞。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>诸神之首奥丁乃引诸神卜居于远离大地的一块平原，这平原在不冻的大河伊文（Ifing）之彼岸，名为伊达瓦尔德（Idawald）。诸神所居之地名为阿瑟加德（Asgard），辅佐奥丁的有十二位男神（Aesir）和二十四位女神（Asynjur） </li>
</ul>
<h1 id="人类诞生"><a href="#人类诞生" class="headerlink" title="人类诞生"></a>人类诞生</h1><ul>
<li>某一日，奥丁、维利和伟（或说是奥丁、海尼尔(Honir)和洛多尔(Lodur，即洛基Loki)）从神宫中出去，在海滩上走，找到了两片木板，或说是两棵树，一棵是梣树（Ask），另一棵是榆树（Embla），便拿来削成了人的形状。诸神看着自己的作品，很是得意，就决定要利用这手制品。于是奥丁给与其灵魂，海尼尔给以动作和感觉，洛多尔给以血，这样就有了能思索能说话能工作并且有恋爱有希望有生有死的人类，住在地上当地上之主。这新造成的两个人是男女一对（梣树是男，榆树是女），他们生下子女，繁衍不息。</li>
<li>奥丁又创造了一棵巨大的梣树，名为伊格德拉修（Yggdrasil），是为宇宙之树、时间之树、生命之树，充满着整个世界。它着根于辽远的、翻腾着不竭之泉赫瓦格密尔的尼弗尔海姆，还着根于近海之地、着根于乌尔达泉（Urdar<br>brunnr）旁的神之家宅。</li>
</ul>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
  </entry>
  <entry>
    <title>UNDERSCORE指南</title>
    <url>/2016/09/21/UNDERSCORE%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>Underscore是一个JS方法库，可以处理数组或者对象里的项目，过滤数据，对数据进行排序和分组，找出两组数据之间不同或相交的地方，去掉数据列表里重复的东西。<br>Underscore 还提供了一些跟函数相关的方法，比如我们可以把一些方法跟对象绑定到一起，这样在方法里面，可以使用对象里面的属性，我们还可以延时去执行函数，可以防止滥用函数，可以创建一次性的函数。</p>
<a id="more"></a>

<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="each-循环处理列表中的每一个项目"><a href="#each-循环处理列表中的每一个项目" class="headerlink" title="each - 循环处理列表中的每一个项目"></a>each - 循环处理列表中的每一个项目</h2><ul>
<li><p>用法</p>
<blockquote>
<p>_.each(对象，迭代器)</p>
</blockquote>
</li>
<li><p>迭代器的支持三个参数，第一个是value,第二个是key,第三个是对象本身</p>
</li>
<li><p>例：数组</p>
<blockquote>
<p>tracks<br>[“长城”, “农民”, “不可一世”, “遥望”, “温暖的家乡”, “无语问苍天”, “早班火车”]<br>_.each(tracks,function(track,index){…})</p>
</blockquote>
</li>
<li><p>例：对象</p>
<blockquote>
<p>album<br>Object {title: “继续革命”, artist: “Beyond”, releaseDate: “1992-07-31”, location: “香港”}<br>_.each(album, function(value,key){…})</p>
</blockquote>
</li>
</ul>
<h2 id="map-遍历列表项目生成处理后的项目"><a href="#map-遍历列表项目生成处理后的项目" class="headerlink" title="map-遍历列表项目生成处理后的项目"></a>map-遍历列表项目生成处理后的项目</h2><ul>
<li><p>用法和each类似，不同之处在于返回处理后的项目，生成新项目，并不会改变原来的项目</p>
<blockquote>
<p>tracks<br>_.map(tracks,function(track){return “《”+track+”》”})<br>[“《长城》”, “《农民》”, “《不可一世》”, “《遥望》”, “《温暖的家乡》”, “《无语问苍天》”, “《早班火车》”]</p>
</blockquote>
<h2 id="reduce-把列表里的所有值堆砌成一个值"><a href="#reduce-把列表里的所有值堆砌成一个值" class="headerlink" title="reduce-把列表里的所有值堆砌成一个值"></a>reduce-把列表里的所有值堆砌成一个值</h2></li>
<li><p>用法</p>
<blockquote>
<p>_.reduce(对象，function(存储结果，对象的值，对象的键)，存储结果的初始值)</p>
</blockquote>
</li>
</ul>
<h2 id="find-查找到列表里第一个符合条件的项目"><a href="#find-查找到列表里第一个符合条件的项目" class="headerlink" title="find-查找到列表里第一个符合条件的项目"></a>find-查找到列表里第一个符合条件的项目</h2><ul>
<li>用法<br>_.find(列表，function(value,key){return 规则})</li>
</ul>
<h2 id="filter-过滤出数组里所有符合条件的项目"><a href="#filter-过滤出数组里所有符合条件的项目" class="headerlink" title="filter-过滤出数组里所有符合条件的项目"></a>filter-过滤出数组里所有符合条件的项目</h2><ul>
<li>产生一个新数组</li>
<li>用法<blockquote>
<p>_.filter(列表，function(value,key){return 规则})</p>
</blockquote>
</li>
</ul>
<h2 id="reject-和filter作用相反"><a href="#reject-和filter作用相反" class="headerlink" title="reject-和filter作用相反"></a>reject-和filter作用相反</h2><ul>
<li>过滤出数组里所有不符合条件的项目</li>
<li>和filter用法相同</li>
</ul>
<h2 id="where-找到包含特定属性和值得项目"><a href="#where-找到包含特定属性和值得项目" class="headerlink" title="where-找到包含特定属性和值得项目"></a>where-找到包含特定属性和值得项目</h2><ul>
<li><p>用法</p>
<blockquote>
<p>_.where(列表，{属性:值,属性:值})</p>
</blockquote>
</li>
<li><p>如果只想找到第一个符合条件的项目就用<code>_.findWhere</code></p>
</li>
</ul>
<h2 id="every-some-contains-判断列表里面的项目"><a href="#every-some-contains-判断列表里面的项目" class="headerlink" title="every,some,contains-判断列表里面的项目"></a>every,some,contains-判断列表里面的项目</h2><h3 id="every-判断列表里面的项目是不是每个都符合指定条件"><a href="#every-判断列表里面的项目是不是每个都符合指定条件" class="headerlink" title="every-判断列表里面的项目是不是每个都符合指定条件"></a>every-判断列表里面的项目是不是每个都符合指定条件</h3><ul>
<li><p>用法 </p>
<blockquote>
<p>_.every(列表，function(列表里的单个项目){ return 判断条件})</p>
</blockquote>
</li>
<li><p>如果每个项目都满足判断条件，返回true</p>
</li>
</ul>
<h3 id="some-判断列表里是否有项目符合指定条件"><a href="#some-判断列表里是否有项目符合指定条件" class="headerlink" title="some- 判断列表里是否有项目符合指定条件"></a>some- 判断列表里是否有项目符合指定条件</h3><ul>
<li>用法和every类似</li>
<li>如果所有项目里有一个满足判断条件，就返回true</li>
</ul>
<h3 id="contains-判断列表里是否包含指定的value"><a href="#contains-判断列表里是否包含指定的value" class="headerlink" title="contains-判断列表里是否包含指定的value"></a>contains-判断列表里是否包含指定的value</h3><ul>
<li>用法<blockquote>
<p>_contains(列表，value)</p>
</blockquote>
</li>
</ul>
<h2 id="pluck-挑出列表里面特定的属性值"><a href="#pluck-挑出列表里面特定的属性值" class="headerlink" title="pluck-挑出列表里面特定的属性值"></a>pluck-挑出列表里面特定的属性值</h2><ul>
<li>用法<blockquote>
<p>_pluck(列表，列表里对象的key)</p>
</blockquote>
</li>
<li>返回一个列表，里面包含指定key对应的所有value</li>
</ul>
<h2 id="max和min-找出列表里最大和最小的项目"><a href="#max和min-找出列表里最大和最小的项目" class="headerlink" title="max和min-找出列表里最大和最小的项目"></a>max和min-找出列表里最大和最小的项目</h2><ul>
<li>简单用法<blockquote>
<p>_.max(列表)</p>
</blockquote>
</li>
<li>扩展用法<blockquote>
<p>_.max(albums,function(album){return album.duration})</p>
</blockquote>
</li>
</ul>
<h2 id="sortBy-排序"><a href="#sortBy-排序" class="headerlink" title="sortBy-排序"></a>sortBy-排序</h2><ul>
<li>用法和max相似，但返回一个新列表</li>
<li>第一个参数是列表，第二个参数是迭代器，可以规定按照对象的哪个属性进行排列<blockquote>
<p>_.sortBy(albums,function(album){return album.duration})</p>
</blockquote>
</li>
</ul>
<h2 id="groupBy-按照对象的指定属性分组"><a href="#groupBy-按照对象的指定属性分组" class="headerlink" title="groupBy-按照对象的指定属性分组"></a>groupBy-按照对象的指定属性分组</h2><ul>
<li>用法和sortBy相似，指定属性相同的对象被归为一组<blockquote>
<p>_.groupBy(albums, 迭代器)</p>
</blockquote>
</li>
</ul>
<h2 id="countBy-分组的计数器"><a href="#countBy-分组的计数器" class="headerlink" title="countBy-分组的计数器"></a>countBy-分组的计数器</h2><ul>
<li>用法和sortBy相同，不过返回的是分组后，每一组包含的项目数</li>
</ul>
<h2 id="shuffle-随机打乱列表顺序"><a href="#shuffle-随机打乱列表顺序" class="headerlink" title="shuffle-随机打乱列表顺序"></a>shuffle-随机打乱列表顺序</h2><ul>
<li>用法 <blockquote>
<p>_.shuffle(列表)</p>
</blockquote>
</li>
</ul>
<h2 id="sample-随机取出列表中的项目"><a href="#sample-随机取出列表中的项目" class="headerlink" title="sample - 随机取出列表中的项目"></a>sample - 随机取出列表中的项目</h2><ul>
<li>用法<blockquote>
<p>_.sample(列表，随机取出的项目数)</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>Canvas</title>
    <url>/2016/09/19/Canvas/</url>
    <content><![CDATA[<p>用canvas写几个小游戏，训练面向对象编程</p>
<a id="more"></a>

<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><p><code>&lt;canvas width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;</code></p>
<ul>
<li>注意 width和height是canvas的自有属性，不是style下的属性</li>
<li>用JS在canvas上作画的基本步骤<ol>
<li>获取canvas节点<blockquote>
<p>var canvas = document.getElementById(“canvas”)</p>
</blockquote>
</li>
<li>设置上下文<blockquote>
<p>var ctx = canvas.getContext(“2d”)</p>
</blockquote>
</li>
<li>描述图形<blockquote>
<p>ctx.fillRect(100,100,200,200)</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h2 id="填充和描边"><a href="#填充和描边" class="headerlink" title="填充和描边"></a>填充和描边</h2><ul>
<li>canvas 绘制的东西，分两种，一种是填充（fill），另一种是描边（stroke）</li>
<li>基本形状是直线、矩形、弧（圆形曲线，贝塞尔曲线）</li>
</ul>
<h3 id="直线"><a href="#直线" class="headerlink" title="直线"></a>直线</h3><ol>
<li>ctx.beginPath()    // 开始画线 </li>
<li>ctx.moveTo(100,100)    //移动到一个点</li>
<li>ctx.lineTo(200,200)   //划线，此时绘制的是一个抽象的线段</li>
<li>ctx.stroke()          // 用描边命令才能显示</li>
<li>ctx.closePath()       // 结束划线，将绘制的线段，封闭</li>
<li>ctx.fill()            // 填充</li>
<li>ctx.lineWidth = “20”  // 划线的宽度</li>
<li>ctx.strokeStyle = “red” // 划线的颜色</li>
<li>ctx. fillStyle = “blue”   // 填充的颜色 </li>
</ol>
<h3 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h3><ul>
<li>ctx.rect(起始点横坐标，起始点纵坐标，宽，高)</li>
<li>ctx.strokeRect() 直接画路径并描边</li>
<li>ctx.fillRect()</li>
</ul>
<h3 id="弧形"><a href="#弧形" class="headerlink" title="弧形"></a>弧形</h3><ul>
<li>arc(x, y, radius, startAngle, endAngle, anticlockwise)</li>
</ul>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><ul>
<li>drawImage(image,sx,xy,sWidth,sHeight,dx,dy,dWidth,dHeight)</li>
<li>s 表示对于原图片的切割，d表示放在画布上的位置</li>
<li>步骤： <ol>
<li>var image = new Image()  // 创建一个图片对象 </li>
<li>image.src = “images/0.jpg” // 设置src，一旦设置src, 上行请求将发出</li>
<li>image.onload = function{ ctx. drawImage()}  //因为图片上行，draw方法异步，所以要用onload事件触发</li>
</ol>
</li>
</ul>
<h1 id="面向对象制作动画"><a href="#面向对象制作动画" class="headerlink" title="面向对象制作动画"></a>面向对象制作动画</h1><h2 id="用面向对象的方法写一个小球的类"><a href="#用面向对象的方法写一个小球的类" class="headerlink" title="用面向对象的方法写一个小球的类"></a>用面向对象的方法写一个小球的类</h2><pre><code>class Ball {
    constructor(x,y,r,color,speed){
        this.x=x;
          this.y=y;
          this.r=r;
          this.color =color;
          this.speed = speed
    }
    update(){
      this.x += this.speed;
    }
    render(){
      ctx.beginPath();
      ctx.arc(this.x,this.y,this.r,0,2*Math.PI,true);
      ctx.fillStyle = this.color;
      ctx.fill();
      ctx.closePath();
    }
}</code></pre><ul>
<li>定义了小球的大小，颜色，移动速度，还有生成小球，小球移动的方法</li>
</ul>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><ul>
<li>实例化一个小球 <code>var b1 = new Ball(100,100,50,&quot;blue&quot;,2)</code></li>
<li>产生运动通过三个步骤完成<ol>
<li>清空画布</li>
<li>让小球移动，即生成移动后的路径</li>
<li>渲染小球</li>
</ol>
</li>
<li>结合<code>定时器</code>把这三个步骤完成<br>  setInterval(function(){<pre><code>  ctx.clearRect(0,0,canvas.width,canvas.height);
  b1.update();
  b1.render();
},10)    </code></pre></li>
</ul>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>重温Javascript</title>
    <url>/2016/09/12/%E9%87%8D%E6%B8%A9Javascript/</url>
    <content><![CDATA[<p>之前JS没学好，现在重新捋一遍</p>
<a id="more"></a>

<h1 id="ES6新功能"><a href="#ES6新功能" class="headerlink" title="ES6新功能"></a>ES6新功能</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul>
<li>声明块级作用域的变量</li>
<li>var 声明，在for循环等语句块中，无法定义具有局部作用域的变量<pre><code>function foo(){
    for (var i=0;i&lt;100;i++){
    }    
    i += 100 // 仍然可以引用变量i
}</code></pre></li>
<li>let声明，就可以创造出真正的块级作用域<pre><code>function foo(){
    for (let i=0;i&lt;100;i++){
        sum += i;
    }
    i+=1; // SyntaxError
}</code></pre></li>
</ul>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul>
<li>不能定义两次const变量, 如果变量是数组，可以更改变量的内容，但仍不可以重新定义</li>
</ul>
<h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><h3 id="解构数组"><a href="#解构数组" class="headerlink" title="解构数组"></a>解构数组</h3><pre><code>function breakfast(){
    return [&quot;cake&quot;,&quot;tea&quot;,&quot;apple&quot;]
}
let [dessert,drink,fruit]=breakfast();
console.log(dessert,drink,fruit);</code></pre><h3 id="解构对象"><a href="#解构对象" class="headerlink" title="解构对象"></a>解构对象</h3><pre><code>function breakfast(){
    return {dessert:&quot;cake&quot;,drink:&quot;tea&quot;,fruit:&quot;apple&quot;}
}
let {dessert: dessert,drink: drink,fruit: fruit}=breakfast();
console.log(dessert, drink,fruit);</code></pre><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><ul>
<li>字符串前后用``括起来</li>
<li>${var}</li>
<li>还可以把字符串用回车切分成多行，不用\n</li>
</ul>
<h3 id="标签模板字符串"><a href="#标签模板字符串" class="headerlink" title="标签模板字符串"></a>标签模板字符串</h3><h3 id="模板字符串的三个判断"><a href="#模板字符串的三个判断" class="headerlink" title="模板字符串的三个判断"></a>模板字符串的三个判断</h3><ul>
<li>startsWith()</li>
<li>endsWith()</li>
<li>includes()</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><pre><code>function breakfast(dessert=&quot;cake&quot;,drink=&quot;coffee&quot;){
    return \`${dessert} ${drink}\`
}</code></pre><h3 id="展开操作符…"><a href="#展开操作符…" class="headerlink" title="展开操作符…"></a>展开操作符…</h3><ul>
<li>…数组  可以将数组展开</li>
</ul>
<h3 id="剩余操作符…"><a href="#剩余操作符…" class="headerlink" title="剩余操作符…"></a>剩余操作符…</h3><pre><code>function breakfast(dessert,drink,...foods){
    console.log(dessert,drink,foods);
}</code></pre><ul>
<li>函数除了接受dessert,drink参数外，剩余的参数被当做叫做foods的数组</li>
</ul>
<h3 id="解构参数"><a href="#解构参数" class="headerlink" title="解构参数"></a>解构参数</h3><pre><code>function breakfast(dessert,drink,{location,restaurant}){
    console.log(dessert,drink,location,restaurant)
}
breakfast(&quot;cake&quot;,&quot;tea&quot;,{location:&quot;LA&quot;,restaurant:&quot;Bubba Gump&quot;})</code></pre><h3 id="函数的name属性"><a href="#函数的name属性" class="headerlink" title="函数的name属性"></a>函数的name属性</h3><ul>
<li>函数名称.name 可以得到函数的名字</li>
</ul>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><blockquote>
<p>let sumUp = (x,y)=&gt; x+y;</p>
</blockquote>
<ul>
<li>如果不只是返回数据，函数体外要加上{}</li>
<li>如果函数体没有参数，要加上空白括号</li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h3><pre><code>let dessert = &quot;cake&quot;;
let drink = &quot;coffee&quot;;
let breakfast = {
    dessert,
    drink,
    breakfast()
}
// 等同于对象
{
    breakfast : function(),
    dessert: &quot;cake&quot;,
    drink: &quot;coffee&quot;
}</code></pre><h3 id="对象属性名"><a href="#对象属性名" class="headerlink" title="对象属性名"></a>对象属性名</h3><ul>
<li>可以用<code>.</code>来为对象添加属性</li>
<li>如果属性包含空格，则必须用<code>[]</code>来添加属性，比如<blockquote>
<p> food[“hot drink”] = “coffee”</p>
</blockquote>
</li>
<li>还可以在<code>[]</code>内嵌入变量</li>
</ul>
<h3 id="Object-is-方法"><a href="#Object-is-方法" class="headerlink" title="Object.is()方法"></a>Object.is()方法</h3><ul>
<li>这个方法用于对比两个值是否相等</li>
<li>因为相等可以用<code>==</code>和<code>===</code>表示，Object.is()主要解决一些JS的语法BUG， 比如</li>
</ul>
<blockquote>
<p>Object.is(NaN,NaN)<br>true<br>Object.is(+0,-0)<br>false</p>
</blockquote>
<h3 id="Object-assign-方法"><a href="#Object-assign-方法" class="headerlink" title="Object.assign()方法"></a>Object.assign()方法</h3><ul>
<li>把一个对象的内容赋予另一个对象</li>
<li>语法： Object.assign(终点，源)</li>
</ul>
<h3 id="Object-setPrototypeOf-方法"><a href="#Object-setPrototypeOf-方法" class="headerlink" title="Object.setPrototypeOf()方法"></a>Object.setPrototypeOf()方法</h3><ul>
<li>创建对象以后改变对象的原型</li>
<li>例子：<pre><code>let breakfast = {
    getDrink(){
        return &apos;tea&apos;;
    }
};
let supper = {
    getDrink(){
        return &apos;beer&apos;;
    }
};
let sunday = Object.create(breakfast);
sunday.getDrink();
// 结果为 &quot;tea&quot;
Object.setPrototypeOf(sunday, supper);
sunday.getDrink();
// 结果为 &quot;beer&quot;</code></pre></li>
</ul>
<h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h3><ul>
<li>可以直接为对象设定<strong>原型</strong></li>
<li>设定方法：<pre><code>let sunday = {
    __proto__: breakfast
};
sunday.__proto__ = dinner;</code></pre></li>
</ul>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><ul>
<li>得到原型对象的属性和方法<pre><code>let sunday = {
    __proto__: breakfast,
    getDrink(){
        return super.getDrink()+&quot;and sunday champagne&quot;;
    }
}
console.log(sunday.getDrink())
// 返回结果 tea and sunday champagne</code></pre></li>
</ul>
<h2 id="生成器与迭代器"><a href="#生成器与迭代器" class="headerlink" title="生成器与迭代器"></a>生成器与迭代器</h2><h3 id="理解迭代器，自己写一个"><a href="#理解迭代器，自己写一个" class="headerlink" title="理解迭代器，自己写一个"></a>理解迭代器，自己写一个</h3><pre><code>function chef(foods){
    let i = 0;
    return {
        next() {
            let done = (i&gt;=foods.length);
            let value = !done ?foods[i++]:undefined
            return {
                value: value,
                done: done
            }
        }
    }
}</code></pre><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><ul>
<li><p>function* 就声明了一个迭代器</p>
</li>
<li><p>yield 后面加上每次调用yield希望返回的结果</p>
</li>
<li><p>举例： </p>
<pre><code>function* chef(){
    yield &quot;tomato&quot;;
    yield &quot;egg&quot;;
}
let leo = chef();
leo.next();</code></pre></li>
<li><p>另一种用法 </p>
<pre><code>let chef = function* (foods){
    for(var i=0; i&lt;foods.length;i++){
        yield foods[i];
    }
}
let leo = chef([&quot;tomato&quot;,&quot;egg&quot;])
leo.next()</code></pre></li>
</ul>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li>class </li>
<li>初始化一个类<pre><code>class Chef {
    constructor(food){
        this.food = food;
    }
    cook(){
        console.log(this.food);
    }
}</code></pre></li>
</ul>
<h3 id="get-and-set"><a href="#get-and-set" class="headerlink" title="get and set"></a>get and set</h3><pre><code>class Chef {
    constructor(food){
        this.food = food;
        this.dish = [];
    }
    get bill(){
        return this.dish;
    }
    set menu(piece){
        this.dish.push(piece);
    }
    cook(){
        console.log(this.food);
    }
}
let leo = Chef();
//把每道菜插入到菜单当中
leo.menu = &quot;西红柿炒鸡蛋&quot;;
leo.menu = &quot;宫保鸡丁&quot;;
// 生成账单
leo.bill </code></pre><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul>
<li>可以让类里的方法，不需要实例化就可以使用</li>
<li>关键字 static</li>
<li>举例<pre><code>class Chef {
    constructor(food){
    this.food = food};
    static cook(special_dish){
        console.log(special_dish)
    }
}
Chef.cook(&quot;火爆腰花&quot;)</code></pre></li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li><p>让一个类继承另一个类的属性和方法</p>
</li>
<li><p>用super 调用父类的属性</p>
</li>
<li><p>举例</p>
<pre><code>class Person {
    constructor(name,birthday){
        this.name = name;
        this.birthday = birthday; 
    }
    intro() {
        return `我叫${this.name},我出生于${this.birthday}`
    }
}

class Chef extends Person {
    constructor(name,birthday){
        super(name,birthday);
    }
}
let leo = new Chef(&quot;leo&quot;,&quot;1992-3-10&quot;)</code></pre></li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul>
<li>类似数组，但不允许有重复的元素</li>
<li>新建Set new Set()</li>
<li>.add(element) 添加元素</li>
<li>.size  查看元素个数</li>
<li>.has(element) 判断是否有某个元素</li>
<li>.delete(element) 删除某个元素</li>
<li>.forEach(函数) 遍历集合中的每个元素，执行函数</li>
<li>.clear() 清空集合</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li>Map 是对于Object的补充，Object的键类型有限，但Map就没有这些限制</li>
<li>新建 new Map()</li>
<li>.set(key:value) key可以是对象、函数、字符串。。。</li>
<li>.size 查看Map 键值对个数</li>
<li>.get(key) 得到对应的值</li>
<li>.delete(key); 删除</li>
<li>.has(key) 判断</li>
<li>.forEach((value,key)=&gt;{})</li>
<li>.clear() 清空</li>
</ul>
<h3 id="forEach-方法"><a href="#forEach-方法" class="headerlink" title="forEach()方法"></a>forEach()方法</h3><ul>
<li><p>ES6 新增处理集合、数组、Map的方法, 内嵌函数，遍历处理集合数组中的元素</p>
</li>
<li><p>注意参数的顺序和含义</p>
</li>
<li><p>数组</p>
<pre><code>var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];
arr.forEach((element,index,array)=&gt;{
                console.log(element);
                console.log(index);
                console.log(arry)
            })</code></pre></li>
<li><p>集合</p>
<pre><code>var s = new Set([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]);
s.forEach((element,sameElement,set)=&gt;{})</code></pre></li>
<li><p>Map</p>
<pre><code>var m = new Map([[1,&apos;a&apos;],[2,&apos;b&apos;],[3,&apos;c&apos;]]);
m.forEach((value,key,map)=&gt;{})</code></pre></li>
</ul>
<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><ul>
<li>导出：在js的底部export 变量或者函数</li>
<li>导入：<ul>
<li>import {导出对象} from “路径”</li>
<li>import * as 替换对象 from “路径”</li>
</ul>
</li>
</ul>
<h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><ul>
<li>export { dinner as supper };</li>
<li>import { breakfast as shit};</li>
</ul>
<h3 id="默认导出导入"><a href="#默认导出导入" class="headerlink" title="默认导出导入"></a>默认导出导入</h3><blockquote>
<p>export default + 默认导出的变量或函数<br>另一种写法 export {变量或函数 as default}<br>import 随便去取个名字（默认没有大括号）from ‘路径’</p>
</blockquote>
<h1 id="函数的补充"><a href="#函数的补充" class="headerlink" title="函数的补充"></a>函数的补充</h1><h2 id="arguments关键字"><a href="#arguments关键字" class="headerlink" title="arguments关键字"></a>arguments关键字</h2><ul>
<li><p>指向当前函数调用者传入的所有参数</p>
<pre><code>function foo(x) {
    alert(x); // 10
       for (var i=0; i&lt;arguments.length; i++) {
    alert(arguments[i]); // 10, 20, 30
    }
}
foo(10, 20, 30);</code></pre></li>
<li><p>包括定义时，没有参数，调用时有参数的情况</p>
<pre><code>function abs() {
    if (arguments.length === 0) {
        return 0;
    }
    for(var i=0;i&lt;arguments.length;i++){
        var x = arguments[i];
        console.log(x&gt;=0?x:-x)
    }
}
abs(-9,10); //9,10</code></pre></li>
<li><p>arguments最常用于判断传入参数的个数，用arguments.length</p>
</li>
<li><p>剩余参数用function (x,y,…rest){} 处理，注意rest不是关键字，可以替换成其他变量</p>
</li>
</ul>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul>
<li><p>this 在函数内部，一定值得是调用该函数的对象</p>
</li>
<li><p>如果函数内部嵌套另一个函数，想要在内层函数里引用this，就要在调用内层函数时把this捕获过来。</p>
</li>
<li><p>函数中的this还可以直接指定，用apply方法，apply有两个参数，第一个参数指定函数指向的对象，第二个参数是Array，表示函数本身的参数</p>
<pre><code>function getAge(){
    var y = new Date().getFullYear();
    return y - this.birth
}   // 这是this指向window

var xiaoming = {
    name : &quot;小明&quot;,
    birth: 1990,
    age: getAge
};
xiaoming.age();  //26
getAge.apply(xiaoming,[]);//26, this指向xiaoming</code></pre></li>
<li><p>call 和 apply 的不同</p>
<ul>
<li>call 也可以指定函数中this的指向，</li>
<li>call()把参数按顺序传入</li>
<li>apply() 把参数打包成数组传输</li>
</ul>
</li>
</ul>
<h1 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h1><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><ul>
<li>创建  <code>var time = new Date()</code> </li>
<li>Date实例几个方法<ul>
<li>.getFullYear() </li>
<li>.getMonth()  // 尤其注意JS里的月份是从0开始算起的</li>
<li>.getDate()</li>
<li>.getDay()   // 周几</li>
<li>.getHours()  </li>
<li>.getMinutes()</li>
<li>.getSeconds()</li>
<li>.getMilliseconds()</li>
<li>.getTime()   // 实例时间到1970年1月1日0时整GMT时区的毫秒数</li>
</ul>
</li>
<li>Date 还可以自定义时间戳 <code>var time = new Date(年,月,日,时,分,秒)</code></li>
<li>另一种自定义时间戳的方法 <code>var time = new Date(1435146562875)</code></li>
<li>Date的集中自带方法<ul>
<li>Date.parse(‘2015-06-24T19:49:22.875+08:00’) 可以将ISO 8601格式的字符串 转换成 数字时间戳, 生成 <code>1435146562875</code></li>
<li>Date.now() 可以生成当前调用方法时  到1970年1月1日0时整GMT时区的毫秒数</li>
</ul>
</li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul>
<li><p>创建正则表达式</p>
<blockquote>
<p>var rel1 = /^\d{3}-\d{3,8}$/<br>var rel2 = new RegExp(‘^\d{3}\-\d{3,8}$’)<br>注意，如果使用第二种写法，因为字符串的转义问题，字符串的两个\实际上是一个\</p>
</blockquote>
</li>
<li><p>验证字符串用<code>test()</code>方法，比如<code>reg1.test(&quot;010-12345&quot;)</code></p>
</li>
</ul>
<h3 id="正则表达式在JS中的应用"><a href="#正则表达式在JS中的应用" class="headerlink" title="正则表达式在JS中的应用"></a>正则表达式在JS中的应用</h3><h3 id="切分字符串"><a href="#切分字符串" class="headerlink" title="切分字符串"></a>切分字符串</h3><blockquote>
<p>‘a,b;; c  d’.split(/[\s,;]+/); // [‘a’, ‘b’, ‘c’, ‘d’];</p>
</blockquote>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul>
<li>用括号对正则表达式的匹配内容进行分组，用.exec()方法匹配成功后，返回一个Array, 第一个元素是匹配到的整个字符串，后面的元素是括号里匹配到的字符串</li>
</ul>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ul>
<li>JS用来传输数据的方法</li>
<li>序列化：可以把对象转化成JSON串<ul>
<li>JSON.stringify(对象，[筛选对象的键值]，’    ‘) </li>
<li>第二个参数还可以传入一个函数，对每个键值对进行先处理，函数的第一个参数是键，第二个参数是值</li>
</ul>
</li>
<li>反序列化：把JSON串转换成相应的对象<ul>
<li>JSON.parse(字符串，function(key,value){}) </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>decorator详解</title>
    <url>/2016/09/04/decorator%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>之前在《Python基础》提过一下decorator, 这次深入探讨和研究一下</p>
<a id="more"></a>

<ul>
<li><p>decorator本质上就是一个高阶函数，他接受一个函数作为参数，返回一个新函数</p>
</li>
<li><p>python中decorator用<strong>@</strong> 语法，可以避免使用手动编写f=decorate()</p>
</li>
<li><p>写一个日志装饰器<br>  def log(f):</p>
<pre><code>def fn(x):
    print(&quot;call&quot;+f.__name__+&quot;()...&quot;)
    return f(x)
return fn </code></pre></li>
<li><p>应用日志装饰器<br>  @log<br>  def factorial(n):</p>
<pre><code>return reduce(lambda x,y:x*y,range(1,n+1))</code></pre><p>  print(factorial(10))</p>
</li>
<li><p>运行结果<br>  call factorial()…<br>  3628800</p>
</li>
<li><p>注意： fn的参数个数，要和之后f的参数个数相同，如果保证任意参数正常调用，使用*args 和**kw<br>  def log(f):</p>
<pre><code>def fn(\*args,\*\*kw):
    print(&quot;call&quot;+f.__name__+&quot;()...&quot;)
    return f(\*args,\*\*kw)
return fn</code></pre></li>
<li><p>练习：打印函数的调用时间<br>  def performance(f):</p>
<pre><code>def fn(\*args,\*\*kw):
    print(&quot;call &quot;+f.__name__+&quot;()...at&quot;+time.asctime()) 
    return f(\*args,\*\*kw)
return fn</code></pre><p>  @ performance<br>  def addTwo(x,y):</p>
<pre><code>return x+y</code></pre><p>  print(addTwo(1,4))<br>  call addTwo()…atSun Sep  4 14:20:19 2016<br>  7</p>
</li>
<li><p>带参数的decorator</p>
<ul>
<li>原理很简单，就是在标准的decorator外面再包裹一个函数，最后返回decorator本身</li>
</ul>
</li>
<li><p>练习：带参数的decorator<br>  import time<br>  def performance(unit):</p>
<pre><code>def decorator(f):
    def fn(\*args,\*\*kw):
        start = time.clock()
        if unit==&quot;ms&quot;:
            print(&quot;call %s using %f ms&quot;%(f.__name__,(time.clock()-start)*1000))
        elif unit==&quot;s&quot;:
            print(&quot;call %s using %f s&quot;%(f.__name__,time.clock()-start))
        else:
            print(unit +&quot;is a unavailable unit&quot;)
        return f(\*args,\*\*kw)
    return fn
return decorator</code></pre></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>闭包函数如何使用循环变量</title>
    <url>/2016/09/04/%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>一般情况下，闭包的函数体内是避免使用循环变量的，因为调用主体函数时， 循环变量一般是执行结束后，返回一个执行后的值。</p>
<a id="more"></a>
<h1 id="先看一下错误实例"><a href="#先看一下错误实例" class="headerlink" title="先看一下错误实例"></a>先看一下错误实例</h1><pre><code>def count():
fs = []
for i in range(1, 4):
    def f():
         return i*i
    fs.append(f)
return fs

f1, f2, f3 = count()
print(f1(),f2(),f3())</code></pre><ul>
<li>预期返回的结果是1，4，9，但实际返回的结果是9，9，9</li>
<li>原因就是当count()函数返回了3个函数时，这3个函数所引用的变量 i 的值已经变成了3</li>
</ul>
<h1 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h1><ul>
<li><p>方法：问题的产生是因为函数只在执行时才去获取外层参数i，若函数定义时可以获取到i，问题便可解决。而默认参数正好可以完成定义时获取i值且运行函数时无需参数输入的功能，所以在函数f()定义中改为f(m = i),函数f返回值改为m*m即可。</p>
</li>
<li><p>代码修改：</p>
<p>  def count():<br>  fs = []<br>  for i in range(1, 4):</p>
<pre><code>def f(m = i):
    return m * m
fs.append(f)</code></pre><p>  return fs</p>
<p>  f1,f2,f3 = count()<br>  print(f1(),f2(),f3())<br>  1,4,9</p>
</li>
</ul>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>MongoDB</title>
    <url>/2016/08/26/Mongodb-NOTE/</url>
    <content><![CDATA[<p>MongoDB的一些基本用法</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/" target="_blank" rel="noopener">安装官方文档</a></p>
<p>brew 安装与启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew tap mongodb/brew</span><br><span class="line">brew install mongodb-community</span><br><span class="line">brew services start mongodb-community</span><br></pre></td></tr></table></figure>

<h2 id="mongo-SHELL"><a href="#mongo-SHELL" class="headerlink" title="mongo SHELL"></a>mongo SHELL</h2><p><a href="https://docs.mongodb.com/manual/mongo/" target="_blank" rel="noopener">mongo SHELL官方文档</a></p>
<p>打开shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure>

<p>查看当前数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db</span><br></pre></td></tr></table></figure>

<p>切换数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use \&lt;database\&gt;</span><br></pre></td></tr></table></figure>

<p>进入数据模型操作数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.MyCollection.insertOne()</span><br><span class="line">db.MyCollection.find()</span><br></pre></td></tr></table></figure>

<p>退出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><p><a href="https://docs.mongodb.com/manual/crud/" target="_blank" rel="noopener">增删改查官方文档</a></p>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.albums.insertOne()</span><br><span class="line">db.albums.insertMany()</span><br></pre></td></tr></table></figure>

<h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><p>例如这样一组数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.inventory.insertMany( [</span><br><span class="line">   &#123; item: &quot;journal&quot;, qty: 25, size: &#123; h: 14, w: 21, uom: &quot;cm&quot; &#125;, status: &quot;A&quot; &#125;,</span><br><span class="line">   &#123; item: &quot;notebook&quot;, qty: 50, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, status: &quot;A&quot; &#125;,</span><br><span class="line">   &#123; item: &quot;paper&quot;, qty: 100, size: &#123; h: 8.5, w: 11, uom: &quot;in&quot; &#125;, status: &quot;D&quot; &#125;,</span><br><span class="line">   &#123; item: &quot;planner&quot;, qty: 75, size: &#123; h: 22.85, w: 30, uom: &quot;cm&quot; &#125;, status: &quot;D&quot; &#125;,</span><br><span class="line">   &#123; item: &quot;postcard&quot;, qty: 45, size: &#123; h: 10, w: 15.25, uom: &quot;cm&quot; &#125;, status: &quot;A&quot; &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<ul>
<li>查找符合<strong>完整</strong>条件的document</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># key的顺序和值必须完全相同</span><br><span class="line">db.inventory.find( &#123; size: &#123; h: 14, w: 21, uom: &quot;cm&quot; &#125; &#125; )</span><br></pre></td></tr></table></figure>

<ul>
<li>查找符合<strong>部分</strong>条件的document</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.inventory.find( &#123; &quot;size.uom&quot;: &quot;in&quot; &#125; )</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<strong>操作符</strong>查找</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#123; &lt;field1&gt;: &#123; &lt;operator1&gt;: &lt;value1&gt; &#125;, ... &#125;</span><br><span class="line">db.inventory.find( &#123; &quot;size.h&quot;: &#123; $lt: 15 &#125; &#125; )</span><br><span class="line">db.inventory.find( &#123; &quot;size.h&quot;: &#123; $lt: 15 &#125;, &quot;size.uom&quot;: &quot;in&quot;, status: &quot;D&quot; &#125; )</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<strong>AND</strong>增加条件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#123; &lt;field1&gt;: &#123; &lt;operator1&gt;: &lt;value1&gt; &#125;, ... &#125;</span><br><span class="line">db.inventory.find( &#123; &quot;size.h&quot;: &#123; $lt: 15 &#125; &#125; )</span><br><span class="line">db.inventory.find( &#123; &quot;size.h&quot;: &#123; $lt: 15 &#125;, &quot;size.uom&quot;: &quot;in&quot;, status: &quot;D&quot; &#125; )</span><br></pre></td></tr></table></figure>

<h3 id="U"><a href="#U" class="headerlink" title="U"></a>U</h3><ul>
<li>update方法有两个参数，第一个是筛选条件，第二个是修改内容</li>
<li>修改一个符合条件的对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.inventory.updateOne(&#123;过滤器&#125;, &#123;</span><br><span class="line">  &lt;update operator&gt;: &#123; &lt;field1&gt;: &lt;value1&gt;, ... &#125;,</span><br><span class="line">  &lt;update operator&gt;: &#123; &lt;field2&gt;: &lt;value2&gt;, ... &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">db.inventory.updateOne(</span><br><span class="line">   &#123; item: &quot;paper&quot; &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     $set: &#123; &quot;size.uom&quot;: &quot;cm&quot;, status: &quot;P&quot; &#125;,</span><br><span class="line">     $currentDate: &#123; lastModified: true &#125;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>修改多个符合条件的对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.inventory.updateMany(&#123;过滤器&#125;, &#123;</span><br><span class="line">  &lt;update operator&gt;: &#123; &lt;field1&gt;: &lt;value1&gt;, ... &#125;,</span><br><span class="line">  &lt;update operator&gt;: &#123; &lt;field2&gt;: &lt;value2&gt;, ... &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">db.inventory.updateMany(</span><br><span class="line">   &#123; &quot;qty&quot;: &#123; $lt: 50 &#125; &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">     $set: &#123; &quot;size.uom&quot;: &quot;in&quot;, status: &quot;P&quot; &#125;,</span><br><span class="line">     $currentDate: &#123; lastModified: true &#125;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>替换一个doc</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.inventory.replaceOne(</span><br><span class="line">   &#123; item: &quot;paper&quot; &#125;,</span><br><span class="line">   &#123; item: &quot;paper&quot;, instock: [ &#123; warehouse: &quot;A&quot;, qty: 60 &#125;, &#123; warehouse: &quot;B&quot;, qty: 40 &#125; ] &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><ul>
<li>删除一个符合条件的文档</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.collection.deleteOne(&#123; &lt;field1&gt;: &lt;value1&gt;, ... &#125;)</span><br><span class="line">db.collection.deleteOne(&#123; &lt;field1&gt;: &#123; &lt;operator1&gt;: &lt;value1&gt; &#125;, ...)</span><br></pre></td></tr></table></figure>

<ul>
<li>删除所有符合条件的文档</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.collection.deleteMany(&#123; &lt;field1&gt;: &lt;value1&gt;, ... &#125;)</span><br><span class="line">db.collection.deleteMany(&#123; &lt;field1&gt;: &#123; &lt;operator1&gt;: &lt;value1&gt; &#125;, ...)</span><br></pre></td></tr></table></figure>

<h2 id="查询结果控制"><a href="#查询结果控制" class="headerlink" title="查询结果控制"></a>查询结果控制</h2><ul>
<li>.size() 查询到的对象数</li>
<li>.limit(N) 最多查到N个结果</li>
<li>.skip(N) 跳过N个查询结果</li>
<li>.sort({属性:1/-1}) 根据某项属性对查询结果进行排序 </li>
</ul>
<h2 id="操作符过滤"><a href="#操作符过滤" class="headerlink" title="操作符过滤"></a>操作符过滤</h2><ul>
<li>找出电影列表里评分大于9.5的电影，返回电影的标题，年份，不返回ID</li>
<li>$gt 大于操作符</li>
<li>$lt 小于操作符</li>
<li>$in/$nin 包含/不包含 操作符，返回genre的值里包含 犯罪 或 剧情的电影</li>
</ul>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>MongoDB</title>
    <url>/2016/08/26/Mongodb/</url>
    <content><![CDATA[<p>MongoDB的一些基本用法</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/" target="_blank" rel="noopener">官方文档</a></p>
<ul>
<li>brew 安装与启动<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew tap mongodb/brew</span><br><span class="line">brew install mongodb-community</span><br><span class="line">brew services start mongodb-community</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="mongo-shell"><a href="#mongo-shell" class="headerlink" title="mongo shell"></a>mongo shell</h2><ul>
<li>打开shell <blockquote>
<p>mongo </p>
</blockquote>
</li>
<li>查看当前数据库<blockquote>
<p>db</p>
</blockquote>
</li>
<li>切换数据库<blockquote>
<p>use <database></p>
</blockquote>
</li>
<li>退出<blockquote>
<p>exit</p>
</blockquote>
</li>
</ul>
<h2 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h2><h3 id="增加一个对象"><a href="#增加一个对象" class="headerlink" title="增加一个对象"></a>增加一个对象</h3><blockquote>
<p>db.albums.insertOne({title:’夜曲’})<br>db.albums.find()<br>{ “_id” : ObjectId(“57be0d54ab7bbec91c834ce7”), “title” : “夜曲” }     <em>_id是自动赋予对象的</em></p>
</blockquote>
<h3 id="增加多个对象"><a href="#增加多个对象" class="headerlink" title="增加多个对象"></a>增加多个对象</h3><blockquote>
<p>db.albums.insertMany或者insert({title:’叶惠美’},{title:’龙卷风’}]) <em>二者返回值不同</em></p>
</blockquote>
<h3 id="修改多个符合条件的对象"><a href="#修改多个符合条件的对象" class="headerlink" title="修改多个符合条件的对象"></a>修改多个符合条件的对象</h3><blockquote>
<p>db.albums.updateMany({过滤器}，{$set:{artist:’周杰伦’}})</p>
</blockquote>
<h3 id="修改一个符合条件的对象"><a href="#修改一个符合条件的对象" class="headerlink" title="修改一个符合条件的对象"></a>修改一个符合条件的对象</h3><blockquote>
<p>db.albums.updateOne/update({过滤器},{$set:{artist:’周杰伦’}})</p>
</blockquote>
<ul>
<li>update方法有两个参数，第一个是筛选条件，第二个是修改内容</li>
<li>$set是操作符， 一定不要忘记</li>
</ul>
<h3 id="删除一个或多个文档"><a href="#删除一个或多个文档" class="headerlink" title="删除一个或多个文档"></a>删除一个或多个文档</h3><blockquote>
<p>db.albums.remove({过滤器},true/false)</p>
</blockquote>
<ul>
<li>true 表示 只删除第一个符合条件的文档</li>
<li>false或者默认，删除所有符合条件的文档</li>
</ul>
<h2 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><blockquote>
<p>db.movies.find({过滤器},{title:1,year:1 _id:0<em>返回结果是否包含</em>})</p>
</blockquote>
<h3 id="查询结果控制"><a href="#查询结果控制" class="headerlink" title="查询结果控制"></a>查询结果控制</h3><ul>
<li>.size() 查询到的对象数</li>
<li>.limit(N) 最多查到N个结果</li>
<li>.skip(N) 跳过N个查询结果</li>
<li>.sort({属性:1/-1}) 根据某项属性对查询结果进行排序 </li>
</ul>
<h3 id="操作符过滤"><a href="#操作符过滤" class="headerlink" title="操作符过滤"></a>操作符过滤</h3><blockquote>
<p>db.movies.find({“rating.average”:{$gt:9.5}},{title:1,year:1,_id:0}) </p>
</blockquote>
<ul>
<li>找出电影列表里评分大于9.5的电影，返回电影的标题，年份，不返回ID</li>
<li>$gt 大于操作符</li>
<li>$lt 小于操作符</li>
<li>$in $nin 包含/不包含 操作符，返回genre的值里包含 犯罪 或 剧情的电影<blockquote>
<p>db.movies.find({genre:{$in:[“犯罪”,”剧情”]}},{title:1,year:1,_id:0})</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>Docker 使用指南</title>
    <url>/2016/08/25/Docker-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>Docker用作生产环境搭建非常方便</p>
<a id="more"></a>

<h1 id="镜像（image）"><a href="#镜像（image）" class="headerlink" title="镜像（image）"></a>镜像（image）</h1><h2 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h2><blockquote>
<p>docker search + 镜像名称</p>
</blockquote>
<h2 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h2><blockquote>
<p>docker images  </p>
</blockquote>
<h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><blockquote>
<p>docker pull + 镜像名称</p>
</blockquote>
<h1 id="容器（container）"><a href="#容器（container）" class="headerlink" title="容器（container）"></a>容器（container）</h1><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><blockquote>
<p>docker run [–name] +昵称 + 镜像名称 + 镜像下的命令 </p>
</blockquote>
<h2 id="查看正在运行的容器"><a href="#查看正在运行的容器" class="headerlink" title="查看正在运行的容器"></a>查看正在运行的容器</h2><blockquote>
<p>docker ps</p>
</blockquote>
<h2 id="查看运行过的所有容器"><a href="#查看运行过的所有容器" class="headerlink" title="查看运行过的所有容器"></a>查看运行过的所有容器</h2><blockquote>
<p>docker ps -a</p>
</blockquote>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><blockquote>
<p>docker rm + 容器的id或名字</p>
</blockquote>
<h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><blockquote>
<p>docker logs + 容器名字<br>docker logs –follow + 容器ID和名字</p>
</blockquote>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><blockquote>
<p>docker start + 容器名字</p>
</blockquote>
<h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><blockquote>
<p>docker stop + 停止容器的名字</p>
</blockquote>
<h2 id="重新启动容器"><a href="#重新启动容器" class="headerlink" title="重新启动容器"></a>重新启动容器</h2><blockquote>
<p>docker restart + 容器名字</p>
</blockquote>
<h2 id="交互容器"><a href="#交互容器" class="headerlink" title="交互容器"></a>交互容器</h2><blockquote>
<p>docker run –interactive -tty centos /bin/bash</p>
</blockquote>
<h2 id="后台运行容器"><a href="#后台运行容器" class="headerlink" title="后台运行容器"></a>后台运行容器</h2><blockquote>
<p>docker run –detach centos ping <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></p>
</blockquote>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2016/08/23/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="regexr.com"><em>测试网站</em> </a></p>
<a id="more"></a>
<h1 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h1><blockquote>
<p>/^hello/igm </p>
</blockquote>
<ul>
<li>i 忽略大小写</li>
<li>g 全局查找 否则只找到第一个出现的对象</li>
<li>m 多行查找 默认为单行 不分析\n</li>
</ul>
<h1 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h1><ul>
<li>.</li>
<li>^</li>
<li>$</li>
</ul>
<h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><ul>
<li>[abc] [123] a或b或c 1或2或3</li>
<li>[.] 搜索 . 号</li>
<li>[^] 表示否定</li>
</ul>
<h1 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h1><ul>
<li>[a-z]</li>
<li>[A-Z]</li>
<li>[0-9]</li>
<li>[\d] 同上，表示匹配所有数字 [\D]表示对[\d]取反</li>
<li>[\w] 表示word 等同于[a-zA-Z0-9_]  [\W] 对[\w]取反</li>
<li>[\s] 或者[ ]表示空格 [\S]表示取反</li>
<li>[\t] 表示tab</li>
<li>[\n] 表示换行符</li>
</ul>
<h1 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h1><ul>
<li>均是指前面的字符</li>
<li>*至少出现0次</li>
<li><ul>
<li>至少出现1次</li>
</ul>
</li>
<li>？出现0次或1次</li>
<li>{n,m} 至少出现n次 至多出现m次</li>
</ul>
<h1 id="群组"><a href="#群组" class="headerlink" title="群组"></a>群组</h1><ul>
<li>（ruby)?可以对字符串设置重复</li>
<li>（|） 可以在括号里使用 逻辑或</li>
</ul>
<h1 id="替代"><a href="#替代" class="headerlink" title="替代"></a>替代</h1><ul>
<li>被()括起来的都可以用$符号捕获到</li>
<li>$1 是第一个括号的群组， $2 是第二个群组 $&amp;是所有内容</li>
<li>(?:) 在群组括号内加入?:，可以使群组不被捕获</li>
<li>括号内的内容可以在之后的表达式中被重复引用<blockquote>
<p>&lt;(h\d)&gt;.+&lt;/\1&gt;</p>
</blockquote>
</li>
</ul>
<h1 id="环视"><a href="#环视" class="headerlink" title="环视"></a>环视</h1><ul>
<li>作为判断条件 不作为被查找内容</li>
<li>(?=#) 表示某个部分为#号 </li>
<li>(?!#) 表示某个部分不是#号</li>
</ul>
<h1 id="字边界"><a href="#字边界" class="headerlink" title="字边界"></a>字边界</h1><ul>
<li>\b 同样作为判断条件，不作为被查找内容</li>
<li>指的的[a-zA-Z0-9_]之外的字符</li>
</ul>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>LINUX NOTES(2)</title>
    <url>/2016/08/19/LINUX-NOTES-2/</url>
    <content><![CDATA[<p>网络与自动化相关</p>
<a id="more"></a>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="定时任务服务crond"><a href="#定时任务服务crond" class="headerlink" title="定时任务服务crond"></a>定时任务服务crond</h2><ul>
<li><p>用来定期执行命令或者指定程序任务的一种服务或者软件</p>
</li>
<li><p>CROND服务默认（每分钟），会检查系统中是否有需要执行的定时任务，如果有，就会根据事先定义好的规则来执行这个定时任务</p>
</li>
<li><p>分钟级别的定时任务用crond, 秒级的用shell脚本 while循环 sleep 1</p>
</li>
<li><p>为什么需要定时任务？</p>
<ul>
<li>服务器自动备份</li>
</ul>
</li>
<li><p>定时任务分类</p>
<ol>
<li>系统自身的定期执行任务 /var/log/messages* /var/log/secure*</li>
<li>用户执行的定时任务<ul>
<li>at适合执行一次就结束的任务，突发性任务（不常用）依赖服务atd</li>
<li>anacron 适合于非7*24小时开机的服务器。 开机执行，检测停机期间没有执行的任务，在开机后一次性执行一遍</li>
<li>crond  crontab是用户用来设置定时任务规则的命令<blockquote>
<p>crontab -l 查看定时任务<br>crontab -r 删除<br>crontab -e 编辑</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>指令的使用格式</p>
<blockquote>
<p>30 * * * *  /bin/bash /tmp/echo.sh</p>
</blockquote>
<p> Example of job definition:<br>.—————- minute (0 - 59)<br>|  .————- hour (0 - 23)<br>|  |  .———- day of month (1 - 31)<br>|  |  |  .——- month (1 - 12) OR jan,feb,mar,apr …<br>|  |  |  |  .—- day of week (0 - 6) (Sunday=0 or 7) OR     sun,mon,tue,wed,thu,fri,sat<br>|  |  |  |  |<br>*  *  *  *  * user-name  command to be executed  </p>
</li>
</ul>
</li>
<li><p>符号</p>
<ul>
<li>*  任意时间都</li>
<li><ul>
<li>表示范围 </li>
</ul>
</li>
<li>， 表示并列</li>
<li>*/num 每隔num            </li>
</ul>
</li>
<li><p>文件位置</p>
<blockquote>
<p>/var/spool/cron/root</p>
</blockquote>
</li>
<li><p>标准输出 和 标准错误输出的三种写法</p>
<blockquote>
<p>/dev/null 2&gt;&amp;1<br>1&gt;/dev/null 2&gt;/dev/null<br>$&gt;/dev/null </p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>learning python 5th edition补充</title>
    <url>/2016/08/16/%E3%80%8Alearning-python-5th-edition%E3%80%8B%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p>读《python手册5》的一些补充</p>
<a id="more"></a>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串的位"><a href="#字符串的位" class="headerlink" title="字符串的位"></a>字符串的位</h2><p><img src="http://7xthfw.com1.z0.glb.clouddn.com/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BD%8D.png" alt="字符串的位"></p>
<h2 id="字符串生成（-）"><a href="#字符串生成（-）" class="headerlink" title="字符串生成（%）"></a>字符串生成（%）</h2><blockquote>
<p>“%s is a %s” % (‘apple’,’fruit’)    # 后面接元组，也可直接跟元组名称<br>“%(category)s is a %(serie)s” % {‘category’:’apple’,’serie’:’fruit’}    # 后面接字典，也可直接跟字典名称<br>x = 1.23456789<br>‘%e | %f | %g’ % (x, x, x)<br>‘1.234568e+00 | 1.234568 | 1.23457’<br>‘%−6.2f | %05.2f | %+06.1f’ % (x, x, x)   # -6表示占6位，左对齐<br>‘1.23 | 01.23 | +001.2’<br>‘%f, %.2f, %.<em>f’ % (1/3.0, 1/3.0, 4, 1/3.0)  # \</em>号表示在后面括号里赋值<br>‘0.333333, 0.33, 0.3333’</p>
</blockquote>
<h2 id="字符串生成（format）"><a href="#字符串生成（format）" class="headerlink" title="字符串生成（format）"></a>字符串生成（format）</h2><blockquote>
<p>template = ‘{0}, {1} and {2}’<br>template.format(‘spam’, ‘ham’, ‘eggs’)<br>‘spam, ham and eggs’</p>
</blockquote>
<blockquote>
<p>template = ‘{motto}, {pork} and {food}’<br>template.format(motto=’spam’, pork=’ham’, food=’eggs’)<br>‘spam, ham and eggs’</p>
</blockquote>
<blockquote>
<p>template = ‘{motto}, {0} and {food}’<br>template.format(‘ham’, motto=’spam’, food=’eggs’)<br>‘spam, ham and eggs’</p>
</blockquote>
<blockquote>
<p>template = ‘{}, {} and {}’ # By relative position<br>template.format(‘spam’, ‘ham’, ‘eggs’)<br>‘spam, ham and eggs’</p>
</blockquote>
<blockquote>
<p>‘{0:10} = {1:10}’.format(‘spam’, 123.4567)<br>‘spam     =   123.4567’<br>‘{0:&gt;10} = {1:&lt;10}’.format(‘spam’, 123.4567)<br>‘      spam=123.4567    ‘<br>‘{0.platform:&gt;10} = {1[kind]:&lt;10}’.format(sys, dict(kind=’laptop’))<br>‘    darwin=laptop     ‘</p>
</blockquote>
<h1 id="元组和序列"><a href="#元组和序列" class="headerlink" title="元组和序列"></a>元组和序列</h1><h2 id="定义一个有名称的元组"><a href="#定义一个有名称的元组" class="headerlink" title="定义一个有名称的元组"></a>定义一个有名称的元组</h2><blockquote>
<p>from collections import namedtuple<br>Red = namedtuple(‘blue’,[‘name’,’age’,’jobs’])<br>red = Red(‘Bob’,40.5,[‘dev’,’mgr’])<br>red<br>blue(name=’Bob’, age=40.5, jobs=[‘dev’, ‘mgr’])</p>
</blockquote>
<h2 id="可执行对象"><a href="#可执行对象" class="headerlink" title="可执行对象"></a>可执行对象</h2><ul>
<li><p>eval()可以讲字符串转化为可执行对象</p>
</li>
<li><p>pickle模块 将对象直接存储到文件中并读取,通过pickle.dump()和pickle.load()两个函数</p>
<pre><code>D = {&apos;a&apos;: 1, &apos;b&apos;: 2}
F = open(&apos;datafile.pkl&apos;, &apos;wb&apos;)
import pickle
  pickle.dump(D, F) 
F.close()
F = open(&apos;datafile.pkl&apos;, &apos;rb&apos;)
E = pickle.load(F) 
  E
{&apos;a&apos;: 1, &apos;b&apos;: 2} </code></pre></li>
<li><p>对象和JSON的转换</p>
<pre><code>rec
{&apos;job&apos;: [&apos;dev&apos;, &apos;mgr&apos;], &apos;name&apos;: {&apos;last&apos;: &apos;Smith&apos;, &apos;first&apos;: &apos;Bob&apos;}, &apos;age&apos;: 40.5}       
import json
json.dumps(rec)
&apos;{&quot;job&quot;: [&quot;dev&quot;, &quot;mgr&quot;], &quot;name&quot;: {&quot;last&quot;: &quot;Smith&quot;, &quot;first&quot;: &quot;Bob&quot;}, &quot;age&quot;: 40.5}&apos;
S = json.dumps(rec)
S
&apos;{&quot;job&quot;: [&quot;dev&quot;, &quot;mgr&quot;], &quot;name&quot;: {&quot;last&quot;: &quot;Smith&quot;, &quot;first&quot;: &quot;Bob&quot;}, &quot;age&quot;: 40.5}&apos;
O = json.loads(S)
O
{&apos;job&apos;: [&apos;dev&apos;, &apos;mgr&apos;], &apos;name&apos;: {&apos;last&apos;: &apos;Smith&apos;, &apos;first&apos;: &apos;Bob&apos;}, &apos;age&apos;: 40.5}</code></pre></li>
<li><p>把对象以JSON形式从到文件中并读取</p>
<pre><code>json.dump(rec, fp=open(&apos;testjson.txt&apos;, &apos;w&apos;), indent=4) \# indent表示缩进
print(open(&apos;testjson.txt&apos;).read())</code></pre></li>
</ul>
<h2 id="赋值、浅拷贝、深拷贝"><a href="#赋值、浅拷贝、深拷贝" class="headerlink" title="赋值、浅拷贝、深拷贝"></a>赋值、浅拷贝、深拷贝</h2><pre><code>import copy
new  = [23,44,122,[&apos;a&apos;,&apos;b&apos;]]
new2 = new
newcopy = copy.copy(new)
newdeepcopy = copy.deepcopy(new)
new.append(0)
new[3].append(&apos;c&apos;)
print(new)
[23, 44, 122, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 0]
print(new2)
[23, 44, 122, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 0]
print(newcopy)
[23, 44, 122, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]
print(newdeepcopy)
[23, 44, 122, [&apos;a&apos;, &apos;b&apos;]]</code></pre><ul>
<li>赋值是完全相同的对象</li>
<li>copy.copy是复制一个新容器，但容器里的对象指向原来的对象</li>
<li>copy.deepcopy 复制一个新容器，占用空间生成新的容器对象</li>
</ul>
<h1 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h1><h2 id="python3-X的print"><a href="#python3-X的print" class="headerlink" title="python3.X的print"></a>python3.X的print</h2><blockquote>
<p>print([object, …][, sep=’ ‘][, end=’\n’][, file=sys.stdout][, flush=False])</p>
</blockquote>
<ul>
<li>sep 的值为打印对象间 插入的 字符串</li>
<li>file 后面接 导出的文件 如 file= open(‘output.txt’,’w’)</li>
<li>flush取决于file，如果file确定，flush的值就为真</li>
</ul>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>PYTHON基础</title>
    <url>/2016/07/30/PYTHON%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>懂了javascript, python学的就是快</p>
<a id="more"></a>
<h1 id="PYTHON的关键要素"><a href="#PYTHON的关键要素" class="headerlink" title="PYTHON的关键要素"></a>PYTHON的关键要素</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>Intergral 类型<ul>
<li>整形：不可变对象; -257</li>
<li>布尔型: True, False</li>
</ul>
</li>
<li>浮点类型<ul>
<li>浮点数：3.141592</li>
<li>复数 ： 3+6j</li>
</ul>
</li>
<li>字符串： ‘GNU IS NOT UNIX’(是序列)，不可变对象   </li>
</ul>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><ul>
<li>type(name) 显示对象的数据类型</li>
<li>id(name) 对象身份</li>
<li>len() 获取变量中元素个数</li>
<li>range() 生成一个序列</li>
</ul>
<h2 id="对象引用（变量）"><a href="#对象引用（变量）" class="headerlink" title="对象引用（变量）"></a>对象引用（变量）</h2><ul>
<li>python将所有数据存为内存对象</li>
<li>变量事实上是指向内存对象的引用</li>
<li>“=” 用于将变量名与内存中的某对象绑定： 如果对象事先存在，就直接进行绑定，否则，则由“=” 创建引用的对象</li>
<li>命名惯例<ul>
<li>以单一下划线开头的变量名（_x）不会被from module import 语句导入</li>
<li>前后有双下划线的变量名（<strong>x</strong>）是系统定义的变量名，对解释器有特殊意义</li>
<li>__x 类的本地变量</li>
<li>交互模式下， 变量名’_’用于表示表达式的最后一个结果</li>
</ul>
</li>
<li>变量名没有类型，对象才有</li>
</ul>
<h2 id="组合数据类型"><a href="#组合数据类型" class="headerlink" title="组合数据类型"></a>组合数据类型</h2><ul>
<li>序列类型<ul>
<li>列表 [‘call’,’me’,’hua’], 可变对象，支持原处修改</li>
<li>元组 ()， 不可变对象，(“one”,”two”)</li>
<li>字符串也属于序列类型 name = ‘jerry’;name[0:2:步进];name第0个字符到第2个字符  </li>
</ul>
</li>
<li>集合类型 set </li>
<li>映射类型 字典</li>
</ul>
<h2 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h2><ul>
<li>is 身份操作符 判断左端对象引用是否相同于有段对象引用</li>
</ul>
<h2 id="控制流语句"><a href="#控制流语句" class="headerlink" title="控制流语句"></a>控制流语句</h2><ul>
<li>if</li>
<li>while</li>
<li>for…in </li>
<li>try 异常捕获</li>
</ul>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><blockquote>
<p>print “%format %format2” % (var1, var2)</p>
</blockquote>
<ul>
<li><p>格式</p>
<ul>
<li>d 十进制整数</li>
<li>f 浮点数</li>
<li>g 格式化代码生成字符串</li>
</ul>
</li>
<li><p>%后面可以使用修饰符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%[(name)][flags][width][.precicion]typecode</span><br></pre></td></tr></table></figure>

<ul>
<li>name表示属于后面字典的键名</li>
<li>flag<ul>
<li><ul>
<li>：表示左对齐，默认为右对齐</li>
</ul>
</li>
<li><ul>
<li>：表示包含数字符号，整数也会带 “+”</li>
</ul>
</li>
<li>0 ：表示一个零填充</li>
</ul>
</li>
</ul>
</li>
<li><p>dir(__builtins__) 查看python启动时的内置函数</p>
</li>
<li><p>help(模块内容)</p>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>每个python函数都有一个返回值，默认为none，也可以使用return value明确定义返回值</li>
<li>def语句会创建一个函数对象，并同时创建一个指向函数的对象引用</li>
<li>函数也是对象，可以存储在组合数据类型中，也可以作为参数传递给其他函数</li>
<li>callable()可用于测试函数是否可调用</li>
</ul>
<h1 id="PYTHON的编程风格"><a href="#PYTHON的编程风格" class="headerlink" title="PYTHON的编程风格"></a>PYTHON的编程风格</h1><h2 id="语句和语法"><a href="#语句和语法" class="headerlink" title="语句和语法"></a>语句和语法</h2><ul>
<li>注释 #</li>
<li>续行<ul>
<li>\</li>
<li>‘’’: 闭合操作符，单一语句跨多行</li>
</ul>
</li>
<li>代码组<ul>
<li>缩进相同的一组语句构成一个代码块</li>
<li>首行以关键字开始，如if，while, 以:结束</li>
<li>python使用缩进来分隔代码组，同一代码组的代码行必须严格左对齐，否则会造成语法错误</li>
</ul>
</li>
<li>同一行放置多个语句 ;</li>
<li>模块<ul>
<li>每一个python脚本文件都可以被当做是一个模块，模块名称即脚本文件的名称</li>
<li>模块里的代码可以是一段可直接执行的脚本，也可以是一些类似库函数的代码，可以从别的模块导入(import)    </li>
</ul>
</li>
</ul>
<h2 id="基本编程风格"><a href="#基本编程风格" class="headerlink" title="基本编程风格"></a>基本编程风格</h2><ul>
<li>注释 </li>
<li>文档:python允许通过<strong>doc</strong>动态获得文档字串(获取任何一种类型的简要帮助)</li>
<li>缩进 统一缩进4个字符</li>
<li>标识符名称 见名知意</li>
<li>风格指南：<a href="https://code.google.com/p/soc/wiki/PythonStyleGuide" target="_blank" rel="noopener">https://code.google.com/p/soc/wiki/PythonStyleGuide</a></li>
<li>基本结构</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\# &#x2F;usr&#x2F;bin&#x2F;env python       *起始行*</span><br><span class="line">&quot;this is a test module&quot;      *模块文档*</span><br><span class="line">import sys                   *模块导入*</span><br><span class="line">import os  </span><br><span class="line">debug &#x3D; True                 *(全局)变量定义*</span><br><span class="line">class FooClass(object):      *类定义（如果有）*</span><br><span class="line">    &quot;Foo class&quot;</span><br><span class="line">    pass</span><br><span class="line">def test():                  *函数定义（如果有）*</span><br><span class="line">    &quot;test function&quot;</span><br><span class="line">    foo &#x3D; FooClass()</span><br><span class="line">    if debug:</span><br><span class="line">        print &#39;ran test()&#39;    </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:   *主程序*</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>

<ul>
<li>每个模块都有一个名为<strong>name</strong>的内建变量，此变量值会根据调用此模块的方式发生变化，如果此文件被作为模块倒入，则<strong>name</strong>的值为模块名称，如果此文件被直接执行，则<strong>name</strong>的值为’<strong>main</strong>‘</li>
</ul>
<h1 id="PYTHON对象类型及其运算"><a href="#PYTHON对象类型及其运算" class="headerlink" title="PYTHON对象类型及其运算"></a>PYTHON对象类型及其运算</h1><h2 id="两个对象的比较"><a href="#两个对象的比较" class="headerlink" title="两个对象的比较"></a>两个对象的比较</h2><ol>
<li>值比较：对象中的数据是否相同 ==</li>
<li>身份比较：两个变量名引用的是否为同一对象 A is B</li>
<li>类型比较：两个对象是否相同  type(A) is type(B)</li>
</ol>
<h2 id="核心数据类型"><a href="#核心数据类型" class="headerlink" title="核心数据类型"></a>核心数据类型</h2><ul>
<li>数字： int, long, float, complex, bool</li>
<li>字符： str, unicode</li>
<li>列表： list</li>
<li>字典： dict</li>
<li>元组： tuple</li>
<li>文件： file</li>
<li>其他类型： 集合（set）, frozenset, 类类型，none</li>
<li>其他文件类工具：pipes,fifos, sockets,</li>
</ul>
<h2 id="类型转换："><a href="#类型转换：" class="headerlink" title="类型转换："></a>类型转换：</h2><ul>
<li>str()（只输出一次，不改变类型）, repr()（改变类型）或format(): 将非字符型数据转换为字符 </li>
<li>int() 转为整数</li>
<li>list(str) 将字串转换为列表</li>
<li>dict(d): 创建字典，d必须为键值对的元组序列 d = [(‘a’,1),(‘b’,2),(‘c’,3)]</li>
<li>ord(x) 将字符转换为整数值</li>
<li>hex() 将整数转换为十六进制字符</li>
</ul>
<h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><ul>
<li>True : 1</li>
<li>False:0</li>
</ul>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul>
<li>x+y</li>
<li>x-y</li>
<li>x*y</li>
<li>x/y</li>
<li>x//y(截断除法)</li>
<li>x**y 乘方</li>
<li>x % y 取模</li>
<li>x &lt;&lt; y 二进制左移y位</li>
<li>x &gt;&gt; y 二进制右移y位</li>
<li>x &amp; y 按位与</li>
<li>x | y 按位或</li>
<li>x ^ y 按位异或</li>
<li>~x 按位求反</li>
</ul>
<h2 id="序列类型"><a href="#序列类型" class="headerlink" title="序列类型"></a>序列类型</h2><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><ul>
<li>字面量： 把文本放入单引号、双引号或三引号中：</li>
<li>如果使用unicode编码  str = u”hello”</li>
<li>文档字串：模块、类或函数的第一条语句是一个字符的话，该字符串就成为文档字符串，可以使用<strong>doc</strong>调用</li>
<li>运算<ul>
<li>索引运算： s[i]</li>
<li>切片运算： s[i:j] （切片会生成新的对象）</li>
<li>扩展切片： s[i:j:stride] </li>
<li>min(s)和max(s)</li>
<li>sum()</li>
<li>all(s) 检查s的所有项是否为true</li>
<li>any()  检查任意项是否为true</li>
<li>分隔符.join(str),在集合每一个元素之间添加分隔符</li>
<li>s.replace(old,new)</li>
<li>s.split(分割的元字符)</li>
<li>s.strip(chars) 修建字串左右两端的字符（空白或指定字符）</li>
</ul>
</li>
</ul>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul>
<li>容器类型： 任意对象的有序集合，通过索引访问其中的元素，对象可变，异构，任意嵌套</li>
<li>支持在原处修改：修改指定的元素，删除元素（指定分片定义为空列表，或del()函数）</li>
<li>方法<ul>
<li>del(list[])</li>
<li>list.append(列表结尾附加元素)</li>
<li>list.count(something) 统计指定值出现的次数</li>
<li>list.extend(list) 用迭代的方法把另一个列表中的元素</li>
<li>list.insert(索引位置，插入元素)</li>
<li>list.pop(弹出一个元素，默认为最后一个元素)，返回被弹出的元素</li>
<li>list.remove(指定元素) 删除第一次出现的指定元素</li>
<li>list.sort()排序</li>
<li>list.reverse()逆序， 排序和逆序为原处修改，不会返回任何值</li>
</ul>
</li>
<li>运算<ul>
<li>list1 + list2: 合并两个列表，返回一个新列表，不会修改原列表</li>
<li>list * n : 重复列表n次 生成一个新的列表</li>
<li>in ： 成员关系判断，在指定的容器中是否出现指定元素 obj in container</li>
<li>not in : 成员关系判断  obj not in container</li>
<li>list2 = list1 浅复制 指向同一内存对象</li>
<li>list2 = list1[:] 复制列表 成为一个新列表，不指向同一个内存对象</li>
<li>list2 = copy.deepcopy(list1) 效果同上</li>
</ul>
</li>
</ul>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><ul>
<li>tuple</li>
<li>表达式符号 ()</li>
<li>容器类型： 任意对象的有序集合，通过索引访问其中的元素，不可变对象，长度固定，异构，嵌套 </li>
<li>操作<ul>
<li>定义元组时， 可以把小括号省略掉 </li>
<li>t1 + t2</li>
<li>t * n</li>
<li>in</li>
<li>元组不可变，元组内内如果包含可变类型元素，此类元素修改不会生成新的元组</li>
</ul>
</li>
</ul>
<h3 id="字典-dict"><a href="#字典-dict" class="headerlink" title="字典 dict"></a>字典 dict</h3><ul>
<li>通过键实现元素存取 ： 无序集合 ：可变类型容器 ：支持异构，嵌套</li>
<li>{key1:value1, key2:value2,…}</li>
<li>{} 空字典</li>
<li>操作<ul>
<li>dic.clear() 清除字典中所有元素</li>
<li>dic.copy() 字典复制</li>
<li>dic.get(key) 取得对应键的值, 如果引用不存在的键，不会抛出异常</li>
<li>dic.items() 返回一个列表，列表元素为键值对组成的元组</li>
<li>v1, v2…vn = 容器 变量解包</li>
<li>dic.keys() 返回键列表</li>
<li>dic.values() 返回值列表</li>
<li>dic.pop() 弹出指定的key</li>
<li>dic.popitem() 随机弹出键值映射</li>
<li>d1.update(d2) 合并两个字典，如果有键相同，后面键的值会替代前面键的值</li>
<li>dic.iteritems() 返回迭代器对象（python3不适用）</li>
<li>dict(zip(‘xyz’,’123’)) 快速构建字典</li>
</ul>
</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>一组无序排列的 可哈希的值</li>
<li>支持集合关系测试：</li>
<li>支持成员关系测试：</li>
<li>迭代（遍历）</li>
<li>不支持：索引、元素获取、切片</li>
<li>类型：set()，frozenset(),括号内部最多给出一个可迭代的对象</li>
<li>没有特定语法格式，只能通过通常函数创建</li>
</ul>
<h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><ul>
<li>len() 项目数</li>
<li>s.copy() 制作s的一份副本</li>
<li>s.difference(t) 差集</li>
<li>s.intersection(t) 交集</li>
<li>s.isdisjoint(t) 如果s和t没有相同项，则返回True</li>
<li>s.issubset(t) 如果s是t的一个子集，则返回True</li>
<li>s.issuperset(t) 如果s是t的一个超集，则返回True</li>
<li>s.symmetric_difference(t)  返回属于s并t，但不属于s交t的集合（对称差集）</li>
<li>s.union(t) 求并集，返回所有在s或t中的项</li>
<li>s | t 并集</li>
<li>s &amp; t 交集</li>
<li>s ^ t 对称差集</li>
<li>s - t 差集</li>
<li>s.pop() 任意弹出集合中的一个元素</li>
<li>s.update(t) 将t中的元素加入到s, 支持异构</li>
</ul>
<h2 id="容器、类型和对象"><a href="#容器、类型和对象" class="headerlink" title="容器、类型和对象"></a>容器、类型和对象</h2><ul>
<li>列表、元组、字典 各元素可以跨行，最后一个元素后面允许使用逗号</li>
<li>sys.getrefcount(obj) 所有对象都有引用计数，给予某对象新的名称 或者 在别的对象中引用该对象，都会导致其引用计数增加。 </li>
<li>列表和字典都支持两种类型复制，浅复制（新对象指向被复制对象的指向） 和 深复制（递归复制原对象各个新元素）deepcopy()</li>
<li>Python所有对象都是“第一类”，对象都可以当做数据进行处理</li>
<li>所有序列都支持迭代</li>
<li>所有序列都支持的操作和方法： s[i],s[i:j],s[i:j:stride], len(s),min(s),max(s),sum(s),all(s),any(s),s1+s2, s*N, obj in s1, obj not in s1</li>
<li>可变序列的操作<ul>
<li>s[index] = value 元素赋值</li>
<li>s[i:j]= t 切片赋值</li>
<li>del s1[index] 删除元素</li>
<li>del s1[i:j]  删除切片</li>
</ul>
</li>
</ul>
<h1 id="Python的表达式和语句"><a href="#Python的表达式和语句" class="headerlink" title="Python的表达式和语句"></a>Python的表达式和语句</h1><ul>
<li>表达式（某事）</li>
<li>语句（做某事）： 声明变量，调用函数，循环语句，条件语句 …</li>
<li>常见的表达式操作符：<ul>
<li>逻辑运算： x or y, x and y, not x</li>
<li>成员关系运算： x in y, x not in y</li>
<li>对象实例测试： x is y, x not is y</li>
<li>比较运算： x &lt; y, x &gt; y, x &lt;= y, x &gt;= y, x == y, x != y</li>
<li>位运算： x | y, x &amp; y, x ^ y, x &lt;&lt; y, x &gt;&gt; y, </li>
<li>一元运算： -x, +x, ~x(按位取反)</li>
<li>幂运算： x ** y </li>
<li>索引和分片：x[i], x[i:j],x[i:j:stride]</li>
<li>调用： x(…)</li>
<li>取属性： x.attribute</li>
<li>定义： (…) […] {…}</li>
<li>三元选择表达式： x if y else z</li>
<li>匿名函数： lambda args: expression</li>
<li>生成器函数发送协议： yield x</li>
</ul>
</li>
<li>常用语句<ul>
<li>赋值语句</li>
<li>调用</li>
<li>print 打印对象</li>
<li>if/elif/else: 条件判断</li>
<li>for/else: 序列迭代</li>
<li>while/else: 普通循环</li>
<li>pass: 占位符</li>
<li>break</li>
<li>continue</li>
<li>def</li>
<li>return </li>
<li>yield</li>
<li>global: 命名空间</li>
<li>raise: 触发异常</li>
<li>import</li>
<li>from: 模块属性访问</li>
<li>class： 类</li>
<li>try/except/finally: 捕捉异常</li>
<li>del 删除引用</li>
<li>assert 调试检查</li>
<li>with/as 环境管理器 </li>
</ul>
</li>
</ul>
<h1 id="PYTHON的比较操作"><a href="#PYTHON的比较操作" class="headerlink" title="PYTHON的比较操作"></a>PYTHON的比较操作</h1><ul>
<li><p>Python中真和假的含义</p>
<ul>
<li>任何非零数字和非空对象都为真</li>
<li>数字0、空对象和特殊对象none均为假</li>
</ul>
</li>
<li><p>组合条件测试</p>
<ul>
<li>x and y : 逻辑与</li>
<li>x or y : 逻辑或</li>
<li>not x : 非运算</li>
</ul>
</li>
<li><p>语法结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if boolean_expression1:</span><br><span class="line">    suite</span><br><span class="line">elif boolean_expression2:</span><br><span class="line">    suite</span><br><span class="line">else:</span><br><span class="line">    suite</span><br></pre></td></tr></table></figure>
</li>
<li><p>三元表达式</p>
<blockquote>
<p>expr1 if boolean_expr else expr2</p>
</blockquote>
</li>
</ul>
<h1 id="while和for循环"><a href="#while和for循环" class="headerlink" title="while和for循环"></a>while和for循环</h1><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while boolean_expression:</span><br><span class="line">    while_suite</span><br><span class="line">    if boolean_expression2: continue</span><br><span class="line">    if boolean_expression3: break</span><br><span class="line">else: </span><br><span class="line">    else_suite</span><br><span class="line">break: 跳出最内层的循环；</span><br><span class="line">continue: 跳到所处的最近层循环的开始处</span><br><span class="line">pass: 点位语句</span><br><span class="line">else 代码块： 循环正常终止才会执行，如果由break跳出导致，则else不会执行</span><br></pre></td></tr></table></figure>

<ul>
<li>else 分支为可选部分</li>
<li>只要boolean_expression的结果为true, 循环就会执行</li>
<li>boolean_expression的结果为false时终止循环，如果此时有else分支，则会执行    </li>
</ul>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for expression1 in iterable:</span><br><span class="line">    for_suite</span><br><span class="line">    if boolean_expression2: continue</span><br><span class="line">    if boolean_expression3: break</span><br><span class="line">else:</span><br><span class="line">    else_suite</span><br></pre></td></tr></table></figure>

<ul>
<li>for循环比while循环速度快</li>
<li>range(n,N) 一次性产生一个数据元素，这个数据元素是一个连续的整数列表</li>
</ul>
<h3 id="zip-并行遍历"><a href="#zip-并行遍历" class="headerlink" title="zip: 并行遍历"></a>zip: 并行遍历</h3><ul>
<li>取得一个或多个序列为参数，将给定序列中的并排元素配成元组，返回着这些元组的列表（参数长度不同时，zip会以最短序列的长度为准）</li>
<li>可在for循环中用于实现并行迭代  <blockquote>
<p>L1 = [1,2,3,4,5,6,7]<br>L2 = [‘a’,’b’,’c’,’d’,’e’,’f’,’g’]<br>zip(L1,L2)<br>python2 直接返回一个序列<br>[(1, ‘a’), (2, ‘b’), (3, ‘c’), (4, ‘d’), (5, ‘e’), (6, ‘f’), (7, ‘g’)]<br>python3 返回一个对象，可以用for循环展开</p>
</blockquote>
</li>
</ul>
<ul>
<li>zip 也常用于动态构造字典<blockquote>
<p>keys = [1,2,3,4,5,6,7]<br>values= [‘a’,’b’,’c’,’d’,’e’,’f’,’g’]<br>D = {}<br>for (k,v) in zip(keys,values):</p>
<pre><code>D[k] = v</code></pre><p>D<br>{1: ‘a’, 2: ‘b’, 3: ‘c’, 4: ‘d’, 5: ‘e’, 6: ‘f’, 7: ‘g’}  </p>
</blockquote>
</li>
</ul>
<h1 id="Python迭代"><a href="#Python迭代" class="headerlink" title="Python迭代"></a>Python迭代</h1><h2 id="迭代：-重复做一件事"><a href="#迭代：-重复做一件事" class="headerlink" title="迭代： 重复做一件事"></a>迭代： 重复做一件事</h2><ul>
<li>iterable(可迭代)对象<ul>
<li>支持每次返回自己所包含的一个成员的对象</li>
<li>对象实现了<strong>iter</strong>方法<ul>
<li>序列类型，如：list,str,tuple</li>
<li>非序列类型，如： dict, file</li>
<li>用户自定义的一些包含了<strong>iter</strong>() （返回迭代器）或者<strong>getitem</strong>()方法的类, 或者iter()函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="列表解析"><a href="#列表解析" class="headerlink" title="列表解析"></a>列表解析</h2><ul>
<li>列表解析是python迭代机制的一种应用，它常用于实现创建新的列表，因此要放置于[]中</li>
<li>语法<blockquote>
<p>[expression for iter var in iterable]<br>[expression for iter var in iterable if cond expr]<br>S = [i**2 for i in L]<br>S = [i**2 for i in L if i&gt;=3 ] </p>
</blockquote>
</li>
</ul>
<h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><ul>
<li>并不是创建真正的数字列表，而是返回一个生成器对象，此对象在每次计算出一个条目后，把这个条目“yield”出来</li>
<li>语法<blockquote>
<p>(expression for iter var in iterable)<br>(expression for iter var in iterable if cond expr)</p>
</blockquote>
</li>
</ul>
<h2 id="产生偏移和元素"><a href="#产生偏移和元素" class="headerlink" title="产生偏移和元素"></a>产生偏移和元素</h2><ul>
<li>enumerate(序列) 用元素索引和元素本身生成元组</li>
<li>返回一个生成器对象</li>
</ul>
<h1 id="文件系统和文件"><a href="#文件系统和文件" class="headerlink" title="文件系统和文件"></a>文件系统和文件</h1><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><ul>
<li>python内置函数open()用于文件<blockquote>
<p>var_name = open(name,mode,bufsize)</p>
</blockquote>
</li>
<li>open方法可以接受三个参数：文件名、模式、缓冲区域<ul>
<li>open 函数返回的是一个文件对象</li>
<li>mode: 指定文件的打开模式<ul>
<li>简单模式<ul>
<li>r: 只读<blockquote>
<p>open(‘var/log/message.log’,’r’) </p>
</blockquote>
</li>
<li>w: 写入</li>
<li>a: 附加  </li>
</ul>
</li>
<li>在模式后使用“+”，表示同事支持输出和输入操作，如r+,w+,a+</li>
<li>在模式后附加“b”,表示以二进制方式打开，如rb,wb+</li>
</ul>
</li>
<li>bufsize: 定义输出缓存<ul>
<li>0 表示无输出缓存</li>
<li>1 表示使用缓冲</li>
<li>负数表示使用系统默认设置  </li>
<li>正数表示使用近似指定大小的缓冲</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><ul>
<li>file.readline() 按行读取文件</li>
<li>file.tell() 显示当前阅读指针所在行数 </li>
<li>file.seek(偏移量，[whence])<ul>
<li>whence 起点<ul>
<li>0：从文件头  </li>
<li>1：从当前位置</li>
<li>2: 从文件尾部</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><ul>
<li>file.write(字符串)</li>
<li>file.writelines(字符串序列)</li>
<li>file.flush() 文件刷写</li>
<li>file.truncate(行) 截取文件</li>
</ul>
<h2 id="文件系统功能：os"><a href="#文件系统功能：os" class="headerlink" title="文件系统功能：os"></a>文件系统功能：os</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>chdir() 改变工作目录</li>
<li>chroot() 设定当前进程的根目录</li>
<li>listdir() 列出指定目录下的所有文件名</li>
<li>mkdir() 创建指定目录</li>
<li>makedirs() 创建多级目录，父目录不存在，就先创建父目录</li>
<li>getcwd() 创建多级目录</li>
<li>rmdir() 删除目录</li>
<li>removedirs() 删除多级目录</li>
</ul>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul>
<li>mknod() 创建设备文件</li>
<li>remove() 删除文件</li>
<li>unlink() 删除链接</li>
<li>rename() 重命名</li>
<li>stat() 返回文件状态信息</li>
<li>sysmlink（） 创建符号链接</li>
<li>tmpfile() 创建并打开临时文件(w+b)</li>
</ul>
<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><ul>
<li>access(文件,UID) 判定某个用户是否对某文件有访问权限</li>
<li>chmod()  修改权限</li>
<li>chown()  修改u,g</li>
</ul>
<h3 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h3><ul>
<li>os.path</li>
<li>basename() 路径基名</li>
<li>dirname() 目录名</li>
<li>join() 整合文件名</li>
<li>split() 返回dirname(), basename()元组</li>
<li>getsize() 返回文件大小</li>
<li>exists() 判断指定文件是否存在</li>
</ul>
<h1 id="Python-函数"><a href="#Python-函数" class="headerlink" title="Python 函数"></a>Python 函数</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul>
<li><p>四种函数</p>
<ul>
<li>全局函数： 定义在模块中</li>
<li>局部函数： 嵌套于其他函数中</li>
<li>lambda函数： 表达式</li>
<li>方法： 与特定数据类型关联的函数，并且只能与数据类型关联在一起使用</li>
</ul>
</li>
<li><p>语法</p>
<blockquote>
<p>def functionName(parameters):</p>
<pre><code>suite     </code></pre></blockquote>
</li>
<li><p>def是一个可执行语句，因此可以出现在任何能够使用语句的地方，甚至可以嵌套于其他语句，例如if或while中</p>
</li>
<li><p>def创建了一个对象， 并将其赋值给一个变量名（函数名）</p>
</li>
<li><p>return 用于返回结果对象，其为可选，无return语句的函数自动返回None对象 <em>返回多个值时，彼此间用逗号分隔，且组合为元组返回一个对象</em></p>
</li>
<li><p>def语句运行之后，可以在程序中通过函数后附加括号的方式进行调用</p>
</li>
</ul>
<h2 id="函数的作用域"><a href="#函数的作用域" class="headerlink" title="函数的作用域"></a>函数的作用域</h2><ul>
<li>作用域： 变量所能生效的范围</li>
<li>函数定义了本地作用域，而模块定义了全局作用域<ul>
<li>每个模块都是一个全局作用域，因此全局作用域仅限于单个程序文件</li>
<li>每次对函数的调用都会创建一个新的本地作用域，赋值的变量除非声明为全局变量，否则均为本地变量</li>
<li>所有的变量名都可以归纳为本地、全局和内置</li>
</ul>
</li>
</ul>
<h2 id="参数匹配模型"><a href="#参数匹配模型" class="headerlink" title="参数匹配模型"></a>参数匹配模型</h2><ul>
<li>参数传递形式：<ul>
<li>位置参数：从左向右</li>
<li>关键字参数：按关键名称匹配</li>
<li>定义函数时，使用默认参数 ： 混用时，无默认值放前面</li>
<li>可变参数： 可收集众多参数 def printName(*x)收集到的参数当做元组识别，def printName(**x) 收集到的参数当做字典识别</li>
<li>可变参数解包：调用时使用，分解参数序列，序列中元素个数必须和参数个数匹配</li>
</ul>
</li>
</ul>
<h2 id="匿名函数lambda"><a href="#匿名函数lambda" class="headerlink" title="匿名函数lambda"></a>匿名函数lambda</h2><ul>
<li>lambda args: expression（表达式 不能是 语句）</li>
<li>lambda语句定义的代码必须是合法表达式，不能出现多条件语句（可使用if的三元表达式）和 其他非表达式语句（for,while等）</li>
<li>lambda的首要用途是指定短小的回调函数</li>
<li>lambda将返回一个函数而不是将函数赋值给某个变量名</li>
<li>expression和 def中的 return 结果相似</li>
<li>lambda也支持使用默认参数</li>
</ul>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><ul>
<li>过滤器 filter（func<em>函数名称，而非调用</em>,seq）  func 为布尔函数，seq中的元素作为func的参数，返回值为非空（True）的元素，生成一个新的序列</li>
<li>映射器 map(func,seq1,seq2…) 后面有几个列表，前面的func就有几个参数</li>
<li>折叠器 reduce(func, seq,init) func要有两个参数</li>
<li>装饰器<ol>
<li>装饰器本身是一个函数，用于装饰其他函数</li>
<li>功能： 增强被装饰函数的功能</li>
<li>调用 @deco</li>
</ol>
</li>
</ul>
<pre><code>def deco(func):
 def wrapper():
     print &quot;perface&quot;
     func()
     print &quot;conclusion&quot;
  return wrapper</code></pre><ul>
<li>递归<ul>
<li>10+9+8+7+6+5+4+3+2+1<pre><code>def digui(n):
    if n&lt;=1:
        return 1
    else:
        return n+digui(n-1)     </code></pre></li>
</ul>
</li>
</ul>
<h1 id="Python的类和面向对象"><a href="#Python的类和面向对象" class="headerlink" title="Python的类和面向对象"></a>Python的类和面向对象</h1><h2 id="类间关系"><a href="#类间关系" class="headerlink" title="类间关系"></a>类间关系</h2><ul>
<li>依赖（“uses-a”） 一个类的方法操纵另一个类的对象</li>
<li>聚合 (“has-a”)  类A的对象包含类B的对象</li>
<li>继承 (“is-a”)   描述特殊与一般关系</li>
</ul>
<h2 id="面向对象编程的原则"><a href="#面向对象编程的原则" class="headerlink" title="面向对象编程的原则"></a>面向对象编程的原则</h2><ul>
<li><p>封装</p>
<ul>
<li>隐藏实现方案细节</li>
<li>将代码及其处理的数据绑定在一起的编程机制，用于保证程序和数据不受外部干扰且不会被误用</li>
</ul>
</li>
<li><p>继承</p>
<ul>
<li>一个对象获得另一个对象属性</li>
</ul>
</li>
<li><p>多态</p>
<ul>
<li>允许一个借口被多个通用的类动作使用的特性，具体使用哪个动作与应用场合相关</li>
<li>一个接口 多个方法</li>
</ul>
</li>
<li><p>创建类</p>
<blockquote>
<p>class ClassName(bases):<br>   date = value       定义数据属性<br>   def method(self,…):    定义方法属性</p>
<pre><code>print self.date  </code></pre></blockquote>
</li>
<li><p>实例的特殊属性： 用构造器 __int__   </p>
</li>
<li><p>方法的可用变量  </p>
<ul>
<li>实例变量： 指定变量名称以及实例自身进行引用 self.变量名</li>
<li>局部变量： 方法内部创建的变量</li>
<li>类变量（静态变量）通过指定变量名与类名进行引用 类名.变量名</li>
<li>全局变量： 直接使用<h2 id="类、实例的内建函数"><a href="#类、实例的内建函数" class="headerlink" title="类、实例的内建函数"></a>类、实例的内建函数</h2></li>
</ul>
</li>
<li><p>issubclass()   判断一个类是否由另一个类派生</p>
<blockquote>
<p>issubclass(sub,sup)</p>
</blockquote>
</li>
<li><p>isinstance(实例，类)  判断某个实例是不是一个类的实例</p>
</li>
<li><p>hasattr()</p>
<ul>
<li>布尔函数，判断一个对象是否拥有指定的属性<blockquote>
<p>hasattr(obj,’attr’)</p>
</blockquote>
</li>
<li>同类的函数还有getattr(),setattr()和delattr()</li>
</ul>
</li>
</ul>
<h1 id="Python-模块"><a href="#Python-模块" class="headerlink" title="Python 模块"></a>Python 模块</h1><ul>
<li>模块在物理形式上表现为以.py结尾的代码文件<ul>
<li>模块的文件名就是模块的名字加上.py</li>
<li>每个模块都有自己的名称空间</li>
</ul>
</li>
<li>Python 允许导入其他模块以实现代码重用<ul>
<li>python中，模块也是对象</li>
<li>在一个模块的顶层 定义的所有变量 都在被导入时成为了被导入模块的属性</li>
</ul>
</li>
<li>导入模块<ul>
<li>在导入模块时只能使用模块名，而不能使用带.py后缀的文件名</li>
<li>import<ul>
<li>导入指定的整个模块，包括生成一个以模块名命名的名称空间 <blockquote>
<p>import module<br>import module as module_alias</p>
</blockquote>
</li>
</ul>
</li>
<li>from-import语句<ul>
<li>常用于只导入指定模块的部分属性至当前名称空间<blockquote>
<p>from module import name </p>
</blockquote>
</li>
<li>import 和 from 是可执行语句，类似于def，因此它可以嵌套在if测试中，出现于def中</li>
</ul>
</li>
<li>模块搜索 <ul>
<li>程序主目录</li>
<li>pythonpath目录（如果设置了此变量）</li>
<li>标准链接库目录</li>
<li>任何.pth文件的内容</li>
<li>这四个文件组合起来即为sys.path所包含的路径的序列</li>
</ul>
</li>
</ul>
</li>
<li>python包: 用于将一组模块归并到一个目录中，此目录即为包，目录名为包名<ul>
<li>基于包，python在执行模块导入时，可以指定模块的导入路径<blockquote>
<p>import dir1.dir2.mod1</p>
</blockquote>
</li>
<li>包中必须包含<strong>init</strong>.py文件，通常为空，仅用于扮演初始化的挂钩</li>
</ul>
</li>
<li>发布模块<ul>
<li>distutils模块能够帮助完成模块或程序发布</li>
<li>创建好的发布可以用于安装，也可以上传到PYPI与他人共享</li>
<li>创建发布<ul>
<li>将各代码文件组织到模块容器中</li>
<li>准备一个README或者README.txt</li>
<li>而后在容器中创建setup.py文件</li>
<li>在要发布的容器目录中执行“python setup.py sdist+指定格式（zip,gztar,bztar）”<pre><code>from distutils.core import setup
setup(
  name = &quot;pkg&quot;,
  version = &quot;1.0.0&quot;,
  author = &quot;tricrepe&quot;,
  author_email = &quot;644568681@qq.com&quot;,
  py_modules(各模块名称组成的列表，这些模块可能位于报的根目录下，也可能位于某子包目录) = [],
  url = &quot;&quot;,
  download_url = &quot;&quot;,
  description = &quot;&quot;
  )</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>shell编程双参数模式</title>
    <url>/2016/07/27/shell%E7%BC%96%E7%A8%8B%E5%8F%8C%E5%8F%82%E6%95%B0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>shell编程：模拟bash命令两个可选的arguments的命令脚本 <em>测试成功</em></p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">declare -i SHOWNUMBER&#x3D;0</span><br><span class="line">declare -i SHOWDETAIL&#x3D;0</span><br><span class="line">for I in &#123;1,$#&#125;;do</span><br><span class="line">  if [ $# -gt 0  ];then</span><br><span class="line">  case $1 in</span><br><span class="line">  &quot;--help&quot;)</span><br><span class="line">  echo &quot;&#96;basename $0&#96;你应该这样用：哈哈哈&quot;</span><br><span class="line">  exit 0;;</span><br><span class="line">  &quot;-v&quot;|&quot;--vebose&quot;)</span><br><span class="line">  SHOWDETAIL&#x3D;1</span><br><span class="line">  shift;;</span><br><span class="line">  &quot;-c&quot;|&quot;--count&quot;)</span><br><span class="line">  SHOWNUMBER&#x3D;1</span><br><span class="line">  shift;;</span><br><span class="line">  *)</span><br><span class="line">  echo &quot;你不应该这样用：嘿嘿嘿&quot;</span><br><span class="line">  exit 7</span><br><span class="line">  ;;</span><br><span class="line">  esac</span><br><span class="line">  fi</span><br><span class="line">done</span><br><span class="line">[ $SHOWDETAIL -eq 1 ]&amp;&amp;echo &quot;they are : &#96;who&#96;&quot;</span><br><span class="line">[ $SHOWNUMBER -eq 1 ]&amp;&amp;echo &quot;logged users:&#96;who|wc -l&#96;&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>LINUX NOTE</title>
    <url>/2016/07/14/LINUX-NOTE/</url>
    <content><![CDATA[<p>学习linux, 大神之路</p>
<a id="more"></a>

<h2 id="LINUX-综述"><a href="#LINUX-综述" class="headerlink" title="LINUX 综述"></a>LINUX 综述</h2><ul>
<li>GUI <code>GRAPHIC USER INTERFACE</code></li>
<li>CLI <code>COMMAND LINE INTERFACE</code></li>
</ul>
<h3 id="命令提示符"><a href="#命令提示符" class="headerlink" title="命令提示符"></a>命令提示符</h3><p><code>prompt, bash(shell)</code></p>
<ul>
<li><code>#</code> : root </li>
<li><code>$</code> : 普通用户</li>
</ul>
<h3 id="命令格式："><a href="#命令格式：" class="headerlink" title="命令格式："></a>命令格式：</h3><ul>
<li><strong>命令</strong> + <strong>选项</strong>（短选项【-l -a = -al】；长选项【–word】）+ <strong>参数</strong>（命令分的作用对象） </li>
</ul>
<h3 id="用户的登录"><a href="#用户的登录" class="headerlink" title="用户的登录"></a>用户的登录</h3><ul>
<li><p>su: switch user </p>
<blockquote>
<p>su [-l] 用户名</p>
</blockquote>
</li>
<li><p>passwd: 修改密码 </p>
</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><blockquote>
<p>mkdir 目录也是文件，是路径映射</p>
</blockquote>
<h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>从指定起始点到目的地所经过的位置 绝对路径 相对路径</p>
<ul>
<li>pwd: print workiong directory</li>
<li>最顶级目录<code>/</code></li>
</ul>
<h3 id="列表-list-ls-列表-l"><a href="#列表-list-ls-列表-l" class="headerlink" title="列表 list: ls 列表 -l"></a>列表 list: ls 列表 -l</h3><blockquote>
<p>drwxr-xr-x. 2 vagrant vagrant 4096 7月  13 22:22 sync</p>
</blockquote>
<h4 id="列表内容"><a href="#列表内容" class="headerlink" title="列表内容"></a>列表内容</h4><ol>
<li>文件类型: <ul>
<li>-:普通文件 </li>
<li>d:目录文件 </li>
<li>b:块设备文件（block）</li>
<li>c:字符设备文件（character） </li>
<li>l:符号链接文件（symbolic link file）</li>
<li>p:命令管道（pipe）</li>
<li>s:套接字文件（socket）</li>
</ul>
</li>
<li>文件权限: rwx(owner)rwx(group)rwx(other)</li>
<li>文件硬链接的次数</li>
<li>文件的owner</li>
<li>文件的group</li>
<li>文件大小（size）: 单位是字节</li>
<li>时间戳（timestamp）: 最近一次被**的时间<ul>
<li>访问：access</li>
<li>修改：modify, 文件内容变更</li>
<li>改变：change, metadata, 元数据（属性）</li>
</ul>
</li>
</ol>
<h4 id="列表选项"><a href="#列表选项" class="headerlink" title="列表选项"></a>列表选项</h4><ol>
<li>-h human readable 作单位转换</li>
<li>-a 显示以<code>.</code>开头的隐藏文件<ul>
<li><code>.</code> 表示当前目录</li>
<li><code>..</code>表示父目录 </li>
</ul>
</li>
<li>-d 显示目录自身属性</li>
<li>-i index node, 显示文件的缩隐号码</li>
<li>-R 递归(recursive)显示 </li>
<li>-r 逆序显示</li>
</ol>
<h4 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h4><ul>
<li>cd change directory <ul>
<li>不加参数 回到用户的主目录（home）</li>
<li>进入指定用户的主目录 <code>~+USERNAME</code></li>
<li>cd - : 在当前目录和前一次所在的目录之间来回切换</li>
</ul>
</li>
</ul>
<h4 id="命令类型："><a href="#命令类型：" class="headerlink" title="命令类型："></a>命令类型：</h4><ul>
<li>内置命令（shell内置）</li>
<li>外部命令：在文件系统的某个路径下有一个与命令名称相应的可执行文件</li>
</ul>
<h4 id="环境变量：-命名的内存空间"><a href="#环境变量：-命名的内存空间" class="headerlink" title="环境变量： 命名的内存空间"></a>环境变量： 命名的内存空间</h4><ul>
<li>变量赋值 NAME=Jerry</li>
<li>printenv 打印环境</li>
<li>hash 显示缓存指令</li>
<li>PATH: 使用冒号分隔的路径 命令所在路径必须在PATH中</li>
</ul>
<h4 id="type-显示指令属于哪种类型"><a href="#type-显示指令属于哪种类型" class="headerlink" title="type: 显示指令属于哪种类型"></a>type: 显示指令属于哪种类型</h4><h4 id="date-时间管理"><a href="#date-时间管理" class="headerlink" title="date: 时间管理"></a>date: 时间管理</h4><ul>
<li>硬件时钟：sudo clock/sudo hwclock</li>
<li>系统时钟：date</li>
</ul>
<h4 id="获得命令的使用帮助："><a href="#获得命令的使用帮助：" class="headerlink" title="获得命令的使用帮助："></a>获得命令的使用帮助：</h4><ul>
<li><p>内部命令: <code>help+cmd</code></p>
</li>
<li><p>外部命令： <code>cmd --help</code>  </p>
</li>
<li><p>命令手册： <code>man cmd</code> <em>内部命令一般不使用man查看</em></p>
<ul>
<li><p>显示cmd摘要             </p>
<blockquote>
<p>whatis cmd</p>
</blockquote>
</li>
<li><p>分章节：man 2 read</p>
<ol>
<li>用户命令</li>
<li>系统调用</li>
<li>库调用</li>
<li>特殊文件（设备文件）</li>
<li>文件格式(解释配置文件的语法)</li>
<li>游戏</li>
<li>杂项（miscellaneous）</li>
<li>管理命令（/sbin,/usr/sbin/,/usr/local/sbin）</li>
</ol>
</li>
<li><p>内容语法</p>
<ol>
<li>&lt;&gt; ：必须写的</li>
<li>[] ：可省略的</li>
<li>… ：可以出现多次 </li>
<li>| ：多选一</li>
<li>{}：分组</li>
</ol>
</li>
<li><p>MAN</p>
<ol>
<li>NAME: 命令名称及功能简要说明</li>
<li>SYNOPSIS: 用法说明，包括可用的选项</li>
<li>DESCRIPTION/OPTION: 命令功能的详尽说明，每一个选项的意义 </li>
<li>FILES:此命令相关的配置文件</li>
<li>EXAMPLES:使用实例</li>
<li>SEE ALSO:另外参照</li>
<li>翻屏<ul>
<li>向后翻一屏：SPACE</li>
<li>向前翻一屏：B</li>
<li>向后翻一行: ENTER</li>
<li>向前翻一行: K</li>
</ul>
</li>
<li>查找：<ul>
<li>/+查找内容：</li>
<li>n: 下一个</li>
<li>N: 前一个</li>
</ul>
</li>
<li>退出：Q</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><ol>
<li>/boot: 系统启动相关的文件， 如内核、initrd, 以及grub(bootloader)</li>
<li>/dev: device设备文件 <ol>
<li>块设备：随机访问，数据块（硬盘）</li>
<li>字符设备：线性访问，按字符为单位</li>
<li>设备号： 主设备号 次设备号</li>
</ol>
</li>
<li>/etc: 存放配置文件 里面主要是纯文本文件</li>
<li>/home: 用户的家目录，每一个用户的家目录默认为/home/USERNAME</li>
<li>/root: 管理员的家目录，一般不建议使用root直接登录</li>
<li>/lib: 库文件<ol>
<li>静态库 .a</li>
<li>动态库 windows <code>.dll</code> linux <code>.so</code>(shared object)</li>
</ol>
</li>
<li>/media : 挂载点目录， 挂载移动设备</li>
<li>/mnt: 挂载点目录， 挂载额外的临时文件系统</li>
<li>/net: 杂项目录</li>
<li>/opt: 可选目录 </li>
<li>/proc: 伪文件系统, 内核映射文件，盛放内核工作的统计数据（系统调优）</li>
<li>/sys: 伪文件系统， 跟内核设备相关的属性映射文件</li>
<li>/tmp: 临时文件 每个一个月如果没被访问过会自动被清除 </li>
<li>/var: 可变化文件 <ol>
<li>cache 缓存</li>
<li>lock 文件锁</li>
<li>log 日志</li>
<li>mail 用户邮件转存</li>
<li>run 存放进程id pid</li>
</ol>
</li>
<li>/bin: 可执行文件， 用户命令</li>
<li>/sbin: 可执行文件，管理命令</li>
<li>/usr: universal shared read-only 全局共享只读文件<ol>
<li>/usr/bin 系统运行功能</li>
<li>/usr/sbin</li>
<li>/usr/lib</li>
<li>/usr/local: 第三方软件的安装路径</li>
</ol>
</li>
</ol>
<h2 id="命令类型"><a href="#命令类型" class="headerlink" title="命令类型"></a>命令类型</h2><h3 id="目录管理：-ls-cd-pwd"><a href="#目录管理：-ls-cd-pwd" class="headerlink" title="目录管理： ls cd pwd"></a>目录管理： ls cd pwd</h3><blockquote>
<p>mkdir </p>
</blockquote>
<ul>
<li>-p 直接创建目录中的目录 </li>
<li>-v verbose 显示创建过程 </li>
<li>{} 花括号可展开 ， 的内容<blockquote>
<p>mkdir -pv /mnt/test/{x/m,y} </p>
</blockquote>
</li>
</ul>
<h3 id="文件创建和删除"><a href="#文件创建和删除" class="headerlink" title="文件创建和删除"></a>文件创建和删除</h3><ul>
<li>touch: 主要作用更改时间戳，也可以创建文件</li>
<li>stat: 显示时间戳</li>
<li>vi 1.txt: 通过文本编辑器创建 </li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><blockquote>
<p>rm</p>
</blockquote>
<ul>
<li>-i 显示互动</li>
<li>-f 强制删除</li>
<li>-r 递归</li>
</ul>
<h3 id="复制和移动文件"><a href="#复制和移动文件" class="headerlink" title="复制和移动文件"></a>复制和移动文件</h3><blockquote>
<p>cp SRC DEST</p>
</blockquote>
<ul>
<li>cp可以复制一个文件到一个文件 复制多个文件到一个目录</li>
<li>-p 保留复制文件的权限 owner grp 和时间戳</li>
<li>-P 保持链接的链接属性</li>
<li>-a 归档复制 常用于备份</li>
<li>install 也可以用于复制文件 -d 可用于创建目录</li>
</ul>
<h3 id="查看文本"><a href="#查看文本" class="headerlink" title="查看文本"></a>查看文本</h3><ol>
<li>cat 连接并显示</li>
<li>分屏显示 more : 向后翻 翻到结束自动退出<br>分屏显示 less : 和man一样</li>
<li>head 显示文件的前十行<br>head -1 /etc/issue</li>
<li>tail 显示文件的后十行<br>tail -f 查看文件尾部 不退出 等待显示后续追加给文件的新内容</li>
<li>文本处理<ul>
<li>cut 裁剪字段 -d指定分隔符 默认为一个空格 -f 指定第几个字段<br>-f1,3 -f1-3</li>
<li>文本排序 sort 按行首字符在ASCII码表中的顺序排列（首字符相同，比较第二个字符）<ol>
<li>-n 数值排序</li>
<li>-r 逆序排序</li>
<li>-t 字段分隔符</li>
<li>-k 指定哪一个字段</li>
<li>-u 排序后相同的行只显示一次(相邻且完全一致的行才是重复行)</li>
<li>-f 排序时忽略字符大小写<br>  uniq 找到重复的行</li>
<li>-c 显示文件中行重复的次数</li>
<li>-d 只显示重复的行</li>
</ol>
</li>
<li>文本统计 wc（word count) 行数（-l） 单词数 字节数</li>
<li>字符处理 tr</li>
</ul>
</li>
</ol>
<h2 id="BASH"><a href="#BASH" class="headerlink" title="BASH"></a>BASH</h2><h3 id="命令行编辑"><a href="#命令行编辑" class="headerlink" title="命令行编辑"></a>命令行编辑</h3><h4 id="光标跳转"><a href="#光标跳转" class="headerlink" title="光标跳转:"></a>光标跳转:</h4><ol>
<li>ctrl+a 跳到命令行首</li>
<li>ctrl+e 调到命令行尾</li>
<li>ctrl+u 删除光标至命令行首的内容</li>
<li>ctrl+k 删除光标至命令行尾的内容</li>
<li>ctrl+l 清屏</li>
</ol>
<h3 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h3><h4 id="查看命令历史"><a href="#查看命令历史" class="headerlink" title="查看命令历史"></a>查看命令历史</h4><blockquote>
<p>history</p>
</blockquote>
<p>-c: 清空命令历史</p>
<h4 id="命令历史的使用技巧"><a href="#命令历史的使用技巧" class="headerlink" title="命令历史的使用技巧"></a>命令历史的使用技巧</h4><ol>
<li>！！上一次执行的命令</li>
<li>！string 最近一次以string开头的命令</li>
<li>！$ 可以应用上一个命令最后一个参数,也可以按下esc，再按.</li>
</ol>
<h3 id="命令补全"><a href="#命令补全" class="headerlink" title="命令补全"></a>命令补全</h3><p><strong>两下tab</strong> 查询所有以输入开头的命令或路径</p>
<h3 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h3><blockquote>
<p>alias aliasCMD=CMD</p>
</blockquote>
<p>如果有空格要加引号<br>定义的别名只在当前shell的生命周期中有效<br>撤销别名 unalias</p>
<h3 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h3><p>$(COMMAND) 反引号COMMAND反引号<br>touch file_$(date +%F-%H-%M-%S).txt<br>bash支持的引号：</p>
<ul>
<li>反引号：命令替换</li>
<li>“”: 弱引用，可以实现变量替换</li>
<li>‘’: 强引用，不完成变量替换</li>
</ul>
<h3 id="文件名通配"><a href="#文件名通配" class="headerlink" title="文件名通配"></a>文件名通配</h3><ol>
<li>“ * ” ： 匹配任意长度的任意字符</li>
<li>? : 匹配任意单个字符</li>
<li>[]: 匹配指定范围内的任意单个字符<br>[abc],[a-m],[a-z],[A-Z],[0-9],[a-zA-Z]</li>
<li>“[^]” : 匹配指定范围之外的任意单个字符</li>
<li>man 7 glob 某一类 空格[:space:] 标点符号 [:punct:]<br>小写字母 [:lower:] 大写字母 [:upper:] 大小写字母[:alpha:]<br>数字[:digit:] 数字和大小写字母[:alnum:] </li>
</ol>
<h2 id="用户-组-权限"><a href="#用户-组-权限" class="headerlink" title="用户 组 权限"></a>用户 组 权限</h2><h3 id="文件："><a href="#文件：" class="headerlink" title="文件："></a>文件：</h3><ul>
<li>r:可读，可以使用类似cat命令查看文件内容；</li>
<li>w:可写，可以编辑或删除此文件；</li>
<li>x:可执行，可以在命令提示符下当做命令提交给内核运行</li>
</ul>
<h3 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h3><ul>
<li>r: 可以对此目录执行ls以列出内部的所有文件</li>
<li>w: 可以在此目录创建文件</li>
<li>x: 可以使用cd切换进此目录，也可以使用ls -l查看详细信息</li>
</ul>
<h3 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h3><ol>
<li>account: 登录名</li>
<li>password: 密码</li>
<li>UID</li>
<li>GID: 基本组ID</li>
<li>comment: 注释</li>
<li>HOME DIR</li>
<li>SHELL：用户的默认shell</li>
</ol>
<h3 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h3><ol>
<li>account: 登录名</li>
<li>encrypted password: 加密的密码 !!表示锁定</li>
<li>最近一次修改密码的时间</li>
<li>最短的使用期限</li>
<li>最长的使用期限</li>
<li>警告时间</li>
</ol>
<h3 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h3><ol>
<li>组名</li>
<li>密码</li>
<li>GID</li>
<li>以此组为附加组的用户列表</li>
</ol>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><h4 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h4><blockquote>
<p>useradd [options] USERNAME</p>
</blockquote>
<ul>
<li><p>-u 指定UID UID必须不能重复并且&gt;=500</p>
</li>
<li><p>-g GID 基本组</p>
</li>
<li><p>-G GID,…（附加组 ）</p>
</li>
<li><p>-c “COMMENT”</p>
</li>
<li><p>-d /path/to/somedir 指定家目录</p>
<blockquote>
<p>useradd -c “Tony Blare” -d /home/blare use4 </p>
</blockquote>
</li>
<li><p>-s 指定当前系统可用的安全shell 在/etc/shells中</p>
</li>
<li><p>-M 创建用户 但不创建家目录</p>
</li>
<li><p>-r 添加一个系统用户（系统用户不能登录系统 没有家目录）</p>
</li>
</ul>
<h4 id="查询用户ID"><a href="#查询用户ID" class="headerlink" title="查询用户ID"></a>查询用户ID</h4><blockquote>
<p>id USERNAME(显示用户的UID和组ID) </p>
</blockquote>
<ul>
<li>-u </li>
<li>-g</li>
<li>-G</li>
<li>-n 显示名称而非ID号 </li>
</ul>
<h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><blockquote>
<p>userdel [option] USERNAME</p>
</blockquote>
<ul>
<li>默认不删除用户家目录</li>
<li>-r 删除家目录 </li>
</ul>
<h4 id="修改用户账号属性"><a href="#修改用户账号属性" class="headerlink" title="修改用户账号属性"></a>修改用户账号属性</h4><blockquote>
<p>usermod</p>
</blockquote>
<ul>
<li>-u UID</li>
<li>-g GID(基本组)</li>
<li>-G GID(附加组)  -a -G 为用户追加附加组</li>
<li>-c 注释</li>
<li>-d -m: 一起用 换家目录 并把此前家目录的文件移动到新的目录</li>
<li>-l 修改用户名</li>
</ul>
<h4 id="修改用户shell"><a href="#修改用户shell" class="headerlink" title="修改用户shell"></a>修改用户shell</h4><blockquote>
<p>chsh</p>
</blockquote>
<h4 id="修改或设置密码"><a href="#修改或设置密码" class="headerlink" title="修改或设置密码"></a>修改或设置密码</h4><blockquote>
<p>passwd [USERNAME]</p>
</blockquote>
<ul>
<li>–stdin 标准输入 echo “redhad” | passwd –stdin user4 </li>
<li>-l lock</li>
<li>-u unlock</li>
<li>-d 删除用户密码</li>
</ul>
<h4 id="检查用户帐号的完整性"><a href="#检查用户帐号的完整性" class="headerlink" title="检查用户帐号的完整性"></a>检查用户帐号的完整性</h4><blockquote>
<p>pwck</p>
</blockquote>
<h4 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h4><ul>
<li>创建组 groupadd<ul>
<li>-g 指定GID</li>
<li>-r 添加一个系统组</li>
<li>-m 修改组名</li>
</ul>
</li>
<li>删除组 groupdel<ul>
<li>newgrp GRPNAME 切换到新的组登录 退出 exit</li>
<li>gpasswd 为组设定密码</li>
</ul>
</li>
</ul>
<h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><ul>
<li>chown 改变文件owner (<strong>只有管理员才可以使用此命令</strong>)<ul>
<li>-R 修改目录及其内部文件的owner</li>
<li>–reference=/path/to/somefile FILE(属主 属组都改 )</li>
<li>chown USERNAME:GRPNAME FILE</li>
</ul>
</li>
<li>chgrp (<strong>只有管理员才能使用此命令</strong>)  </li>
<li>修改文件的权限 chmod<ul>
<li>修改三类用户的权限：chmod MODE file<ul>
<li>-R</li>
<li>–reference=path FILE </li>
</ul>
</li>
<li>修改某类用户的权限<ul>
<li>u,g,o,a  chmod 用户类别=mod FILE</li>
</ul>
</li>
<li>修改某类用户的某些权限<ul>
<li>u,g,o,a  chmod 用户类别 +|- mod FILE</li>
</ul>
</li>
</ul>
</li>
<li>umask 遮罩码：创建文件用666-遮罩码 创建目录用777-遮罩码 </li>
</ul>
<h4 id="shell的类型"><a href="#shell的类型" class="headerlink" title="shell的类型"></a>shell的类型</h4><ul>
<li>登录式shell: <ul>
<li>su -USERNAME</li>
<li>su -l USERNAME</li>
</ul>
</li>
<li>非登录式shell:<ul>
<li>su USERNAME</li>
<li>图形终端下打开命令窗口</li>
<li>自动执行的shell脚本</li>
</ul>
</li>
</ul>
<h4 id="bash的配置文件"><a href="#bash的配置文件" class="headerlink" title="bash的配置文件"></a>bash的配置文件</h4><ul>
<li>全局配置： /etc/profile, /etc/profile.d/*.sh, /etc/bashrc</li>
<li>个人配置：~/.bash_profile, ~/.bashrc</li>
<li>profile类文件： <ul>
<li>设定环境变量</li>
<li>运行命令或脚本</li>
</ul>
</li>
<li>bashrc类文件：<ul>
<li>设定本地变量</li>
<li>定义命令别名</li>
</ul>
</li>
<li>登录式shell如何读取配置文件？<ul>
<li>/etc/profile –&gt; /etc/profile.d/*.sh –&gt; ~/.bash_profile –&gt; ~/.bashrc –&gt; /etc/bashrc</li>
</ul>
</li>
<li>非登录式shell如何读取配置文件？<ul>
<li>~/.bashrc –&gt; /etc/bashrc –&gt; /etc/profile.d/*.sh  </li>
</ul>
</li>
</ul>
<h4 id="文件的隐藏属性"><a href="#文件的隐藏属性" class="headerlink" title="文件的隐藏属性"></a>文件的隐藏属性</h4><ul>
<li>chattr +i DIR/FILE 给文件增加隐藏属性  任何人不能删除、修改文件</li>
<li>chattr -i DIR/FILE 去掉隐藏属性</li>
<li>chattr +a DIR/FILE 任何人只能增加数据，不能删除或者修改数据</li>
<li>chattr -a DIR/FILE 去掉隐藏属性</li>
<li>lsattr 查看目录/文件的隐藏属性</li>
</ul>
<h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><h3 id="系统设定"><a href="#系统设定" class="headerlink" title="系统设定"></a>系统设定</h3><ul>
<li>默认输出设备：标准输出，STDOUT,1,键盘</li>
<li>默认输入设备：标准输入，STDIN,0,显示器</li>
<li>标准错误输出：STDRR,2,显示器</li>
</ul>
<h3 id="I-O-重定向"><a href="#I-O-重定向" class="headerlink" title="I/O 重定向"></a>I/O 重定向</h3><ul>
<li>&gt; 输出重定向：覆盖输出</li>
<li>&gt;&gt;: 追加输出</li>
<li>set -C: 禁止对已经存在的文件使用覆盖重定向</li>
<li>set +C: 关闭上述功能</li>
<li>如果要强制覆盖 使用 &gt;|</li>
<li>2&gt;: 重定向错误输出</li>
<li>2&gt;&gt;: 追加错误输出</li>
<li>&amp;&gt;: 重定向标准输出和错误输出至同一个文件  </li>
<li>&lt; 输入重定向 </li>
<li>&lt;&lt;: HERE DOCUMENT</li>
<li>管道：前一个命令的输出，作为后一个命令的输入<ul>
<li>命令1| 命令2|命令3 …  </li>
<li>tee 在屏幕上输出， 并且将数据输入到指定文件中</li>
</ul>
</li>
</ul>
<h2 id="文本查找"><a href="#文本查找" class="headerlink" title="文本查找"></a>文本查找</h2><h3 id="grep-根据模式搜索文本，并将符合模式的文本行显示出来"><a href="#grep-根据模式搜索文本，并将符合模式的文本行显示出来" class="headerlink" title="grep: 根据模式搜索文本，并将符合模式的文本行显示出来"></a>grep: 根据模式搜索文本，并将符合模式的文本行显示出来</h3><blockquote>
<p>grep + [OPTION] + PATTERN + FILE </p>
</blockquote>
<ul>
<li>PATTERN 文本字符和正则表达式元字符组合而成匹配条件  </li>
<li>-i 忽略字符大小写</li>
<li>–color 匹配到的字符加高亮</li>
<li>-v 被模式匹配到的行不显示 没被匹配到的显示</li>
<li>-o 只显示被模式匹配到的字符串</li>
<li>-A + N  连同查到的行前面N行一起显示</li>
<li>-B + N  连同查到的行后面N行一起显示</li>
<li>-C + N  连同查到的行前面与后面N行一起显示</li>
<li>-E 扩展正则表达式 egrep<ul>
<li>不用 <code>\</code></li>
<li>可以用 | 表示“或”， 用（）定义或的范围 </li>
</ul>
</li>
</ul>
<h3 id="正则表达式：REGULAR-EXPRESSION-REGEXP"><a href="#正则表达式：REGULAR-EXPRESSION-REGEXP" class="headerlink" title="正则表达式：REGULAR EXPRESSION, REGEXP"></a>正则表达式：REGULAR EXPRESSION, REGEXP</h3><ul>
<li>元字符<ul>
<li>. 表示任意单个字符</li>
<li>[]匹配指定范围内的任意单个字符</li>
<li>[<code>^</code>] 匹配指定范围外的单个字符</li>
</ul>
</li>
<li>匹配次数 <ul>
<li>* 匹配其前面的字符任意次</li>
<li>.* 任意长度的任意字符</li>
<li>\？ 匹配其前面的字符1次或0次（前面的字符可有可无）  </li>
<li>\{m,n\} 匹配器前面的字符至少m次，至多n次</li>
</ul>
</li>
<li>位置锚定：<ul>
<li>^: 此字符后面的任意内容必须出现在行首</li>
<li>$: 此字符前面的任意内容必须出现在行尾</li>
<li>^$: 空白行 </li>
<li>\&lt;: 其后面的任意字符必须作为单词首部出现</li>
<li>\&gt;: 其前面的任意字符必须作为单词尾部出现</li>
</ul>
</li>
<li>分组<ul>
<li><code>\(\)</code>,比如<code>\(ab\)</code> </li>
<li>后向引用<ul>
<li>\1：重复第一个左括号与其对应的右括号之间的内容</li>
<li>\2：重复第二个左括号与其对应的右括号之间的内容</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="脚本编程"><a href="#脚本编程" class="headerlink" title="脚本编程"></a>脚本编程</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol>
<li><p>本地变量赋值</p>
<blockquote>
<p>NAME=VAR 整个bash进程都可用</p>
</blockquote>
</li>
<li><p>局部变量：local VARNAME=VALUE 作用域为当前代码段 </p>
</li>
<li><p>环境变量：作用域为当前shell进程及其子进程</p>
<ul>
<li>export VARNAME=VALUE  也称为“导出“</li>
<li>或者 先定义 VARNAME=VALUE 再导出 export VARNAME</li>
</ul>
</li>
<li><p>位置变量</p>
<ul>
<li>$1（脚本的第一个参数）</li>
<li>$2（脚本的第二个参数）</li>
<li>shift [n]</li>
</ul>
</li>
<li><p>特殊变量：</p>
<ul>
<li><p>$?: 上一个命令的执行状态返回值； </p>
<ul>
<li>程序执行，可能有两类返回值：<ul>
<li>程序执行结果</li>
<li>程序状态返回代码（0-255）<ul>
<li>0 ：正确执行</li>
<li>1-255：错误执行，1，2，127，系统预留，有特殊意义</li>
</ul>
</li>
</ul>
</li>
<li>$#: 参数的个数</li>
<li>$*: 参数列表</li>
<li>$@: 参数列表   </li>
</ul>
<p>任何脚本在执行时会启动一个子shell进程 </p>
<p>命令行中启动的脚本会继承当前shell环境变量</p>
<p>系统自动执行的脚本（非命令行启动）就需要自我定义需要的各环境变量    </p>
</li>
</ul>
</li>
</ol>
<ol start="6">
<li><p>引用变量：${VAR} 有时{}可以省略</p>
</li>
<li><p>撤销变量</p>
<blockquote>
<p>unset VARNAME</p>
</blockquote>
</li>
<li><p>查看当前shell中的变量</p>
<blockquote>
<p>set</p>
</blockquote>
</li>
<li><p>查看当前shell中的环境变量</p>
<ul>
<li>printenv</li>
<li>env</li>
<li>export</li>
</ul>
</li>
<li><p>可以用<code>:</code>在变量的前后追加字符串</p>
</li>
<li><p>默认变量为字符串</p>
</li>
</ol>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><ul>
<li>命令的堆砌，按实际需要，结合命令流程控制</li>
<li>shebang:魔数</li>
<li>#!/bin/bash</li>
<li># 注释行，不执行  </li>
</ul>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><h4 id="条件测试类型"><a href="#条件测试类型" class="headerlink" title="条件测试类型"></a>条件测试类型</h4><ul>
<li>整数测试</li>
<li>字符测试</li>
<li>文件测试</li>
</ul>
<h4 id="条件测试的表达式"><a href="#条件测试的表达式" class="headerlink" title="条件测试的表达式"></a>条件测试的表达式</h4><ul>
<li>[ expression ]</li>
<li>[[ expression ]]</li>
<li>text expression</li>
</ul>
<h4 id="整数测试："><a href="#整数测试：" class="headerlink" title="整数测试："></a>整数测试：</h4><ul>
<li>-eq 测试两个整数是否相等： 比如 $A -eq $B</li>
<li>-ne 测试两个整数是否不等</li>
<li>-gt 测试一个数是否大于另一个数</li>
<li>-lt 测试一个数是否小于另一个数</li>
<li>-ge 大于或等于</li>
<li>-le 小于或等于</li>
</ul>
<h4 id="命令的逻辑关系"><a href="#命令的逻辑关系" class="headerlink" title="命令的逻辑关系"></a>命令的逻辑关系</h4><ul>
<li><p>逻辑与：&amp;&amp;</p>
<ol>
<li>第一个条件为假时，第二条件不用再判断 </li>
<li>第一个条件为真时，第二条件必须得判断</li>
</ol>
</li>
<li><p>逻辑或：||</p>
</li>
</ul>
<ol>
<li><p>如果user6不存在，就添加user6</p>
<blockquote>
<p>! id user6 &amp;&amp; useradd user6<br>id user6 || useradd user6</p>
</blockquote>
</li>
<li><p>如果/etc/inittab文件的行数大于100，就显示好大的文件</p>
<blockquote>
<p>[ `wc -l /etc/inittab | cut -d ‘ ‘ -f1` -lt 100 ] &amp;&amp; echo “small file”</p>
</blockquote>
<p>   或者</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">LINES&#x3D; \&#96;wc -l &#x2F;etc&#x2F;inittab\&#96;</span><br><span class="line">echo $LINES</span><br><span class="line">FINELINES &#x3D; &#96;echo $LINES | cut -d &#39; &#39; -f1\&#96;</span><br><span class="line">echo $FINELINES</span><br><span class="line">[ $FINELINES -gt 100] &amp;&amp; echo &quot;this is a big file&quot; || echo &quot;this is a small file&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果用户存在，就显示用户已存在，否则，就添加此用户</p>
<blockquote>
<p>id user1 &amp;&amp; echo “user exists.” || useradd user1 </p>
</blockquote>
</li>
<li><p>如果用户不存在，就添加，否则，显示其已经存在</p>
<blockquote>
<p>id user1 &amp;&amp; useradd user1 || echo “user1 exist”</p>
</blockquote>
</li>
</ol>
<h4 id="条件判断，控制结构"><a href="#条件判断，控制结构" class="headerlink" title="条件判断，控制结构"></a>条件判断，控制结构</h4><ul>
<li><p>单分支if语句</p>
<blockquote>
<p>if 判断条件;then<br>statement1<br>statement2<br>…<br>fi</p>
</blockquote>
</li>
<li><p>双分支if语句</p>
<blockquote>
<p>if 判断条件;then<br>statement1<br>statement2<br>…<br>else<br>statement3<br>statement4<br>…<br>fi    </p>
</blockquote>
</li>
<li><p>多分支的if语句</p>
<blockquote>
<p>if 判断条件1；then</p>
<pre><code>statement1</code></pre><p>  …<br>elif 判断条件2；then<br>   statement2<br>   …<br>elif 判断条件3; then<br>   statement3<br>   …<br>else 判断条件4; then</p>
<pre><code>statement4</code></pre></blockquote>
</li>
</ul>
<h4 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h4>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case 变量 in </span><br><span class="line">value1)</span><br><span class="line">  statement</span><br><span class="line">  ...</span><br><span class="line">  ;;</span><br><span class="line">value2)</span><br><span class="line">  statement</span><br><span class="line">  ...</span><br><span class="line">  ;;;</span><br><span class="line">*) </span><br><span class="line">  statement</span><br><span class="line">  ...</span><br><span class="line">  ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>


<h4 id="退出脚本"><a href="#退出脚本" class="headerlink" title="退出脚本"></a>退出脚本</h4><p>定义脚本退出状态码</p>
<blockquote>
<p>exit #</p>
</blockquote>
<p>如果脚本没有明确定义退出状态码，那么，最后执行的一条命令的退出码即为脚本的退出状态码</p>
<h4 id="shell-中如何进行算术运算：A-3-B-6"><a href="#shell-中如何进行算术运算：A-3-B-6" class="headerlink" title="shell 中如何进行算术运算：A=3 B=6"></a>shell 中如何进行算术运算：A=3 B=6</h4><ol>
<li>let C=$A+$B</li>
<li>C=$[$A+$B]</li>
<li>C=$(($A+$B))          </li>
<li>C=`expr $A + $B`(表达式中各操作数及运算符之间要有空格) </li>
</ol>
<h4 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h4><ul>
<li>-e FILE: 测试文件是否存在 [ -e /etc/inittab ]</li>
<li>-f FILE: 测试文件是否为普通文件</li>
<li>-d FILE: 测试指定路径是否为目录</li>
<li>-r  -w -x  FILE: 测试当前用户对指定文件是否有读写执行权限</li>
</ul>
<h4 id="字符测试"><a href="#字符测试" class="headerlink" title="字符测试"></a>字符测试</h4><ul>
<li>== 或一个 = [ $A == $B ] <strong>等号两端要有空格</strong></li>
<li>!=: 测试是否不等，不等为真 等为假</li>
<li><blockquote>
</blockquote>
</li>
<li>&lt;</li>
<li>-n VAR：测试指定字符串是否为空，空为真，不空为假</li>
<li>-z VAR：测试指定字符串是否不为空，不空为真，空为假</li>
</ul>
<h4 id="测试脚本是否有语法错误"><a href="#测试脚本是否有语法错误" class="headerlink" title="测试脚本是否有语法错误"></a>测试脚本是否有语法错误</h4><blockquote>
<p>bash -n FILE</p>
</blockquote>
<h4 id="执行并逐步查看脚本"><a href="#执行并逐步查看脚本" class="headerlink" title="执行并逐步查看脚本"></a>执行并逐步查看脚本</h4><blockquote>
<p>bash -x FILE</p>
</blockquote>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul>
<li><p>for</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for 变量 in 列表；do</span><br><span class="line">循环体</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<ul>
<li><p>生成列表的方法</p>
<ul>
<li>{1..100}</li>
<li>seq 起始数 步进长度 结束数；用命令替换在for中生成列表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;	#!&#x2F;bin&#x2F;bash</span><br><span class="line">	declare -i SUM&#x3D;0</span><br><span class="line">	for I in &#123;1..100&#125;; do</span><br><span class="line">	let SUM&#x3D;$[$SUM+$I]</span><br><span class="line">	done</span><br><span class="line">	echo &quot;The sum is: $SUM&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>while</p>
</li>
<li><p>until</p>
</li>
</ul>
<h3 id="组合测试条件"><a href="#组合测试条件" class="headerlink" title="组合测试条件"></a>组合测试条件</h3><ul>
<li>-a : 与关系</li>
<li>-o : 或关系</li>
<li>！: 非关系</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ $# -gt 1 -a $# -le 3 ]</span><br><span class="line">if [ $# -gt 1 ] &amp;&amp; [ $# -le 3 ]</span><br></pre></td></tr></table></figure>


<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul>
<li><p>sed: Stream EDiter 行编辑器 </p>
</li>
<li><p>默认不编辑源文件，仅对模式空间内的文本进行处理（源文件的副本，而后将模式空间打印出来</p>
<blockquote>
<p>sed [options] ‘AddressCommand’ file …</p>
</blockquote>
</li>
<li><p>Address</p>
<ol>
<li><p>StartLine,Endline；<br>比如1，100；<br>$: 最后一行；</p>
</li>
<li><p>/RegExp/</p>
<blockquote>
<p> /^root/</p>
</blockquote>
</li>
<li><p>/pattern1/ , /pattern2/</p>
<pre><code>第一次被pattern1匹配的行开始，至第一次被pattern2匹配到的行</code></pre></li>
<li><p>linenumber</p>
<pre><code>指定的行</code></pre></li>
<li><p>StartLine +N</p>
<pre><code>从startline开始，向后的N行</code></pre></li>
</ol>
</li>
</ul>
<ul>
<li><p>Command</p>
<ul>
<li><p>d 删除符合条件的行  sed ‘1,2d’ /etc/fstab 删除 /etc/fstab 的前两行</p>
</li>
<li><p>p 显示符合条件的行  </p>
</li>
<li><p>a \“string” : 在指定的行后面追加新行</p>
</li>
<li><p>i \“string” : 在指定的行前面添加新行</p>
</li>
<li><p>r FILE: 将指定的文件和内容添加至符合条件的行处</p>
</li>
<li><p>w FILE: 将地址指定范围内的内容另存至指定的文件中</p>
</li>
<li><p>s/pattern/string/修饰符:  查找并替换, 默认只替换每行中第一次被模式匹配到的字符串。</p>
<blockquote>
<p>sed ‘1,2s/^/#/g’ /etc/fstab 把文件中1、2行的所有/都替换成#</p>
</blockquote>
<ul>
<li>修饰符<ul>
<li>g: 全局替换</li>
<li>i: 查找时忽略字符大小写<ul>
<li>&amp; 泛指查找到的内容（字符串中有模糊的数据）</li>
<li>s/// 也中的/ 也可用其他字符替换，比如### @@@</li>
<li>s/// 支持 后项匹配 \1 \2</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>options</p>
<ul>
<li>-n 不再显示模式空间中的内容          </li>
<li>-i 直接修改源文件</li>
<li>-e SCRIPT -e SCRIPT : 可以同时执行多个脚本</li>
<li>-f /PATH/TO/SED_SCRIPT FILE : 把SED_SCRIPT中的脚本全部应用在FILE中</li>
<li>-r 表示使用扩展RegEXPR <blockquote>
<p>history | sed -r ‘s#^[[:space:]]+*##g’ 把history行首的空格删除</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><blockquote>
<p>vim /path/to/somefile</p>
</blockquote>
<h3 id="vim的模式"><a href="#vim的模式" class="headerlink" title="vim的模式"></a>vim的模式</h3><ul>
<li>编辑模式（命令模式）默认处于编辑模式</li>
<li>输入模式 </li>
<li>末行模式</li>
</ul>
<h3 id="模式转换"><a href="#模式转换" class="headerlink" title="模式转换"></a>模式转换</h3><ul>
<li>编辑–&gt;输入：<ul>
<li>i : 在当前光标所在字符的前面，转化为输入模式</li>
<li>a : 在当前光标所在字符的后面</li>
<li>o : 在当前光标所在行的下方新建一行</li>
<li>I : 在当前光标所在行的行首，转化为输入模式</li>
<li>A : 行尾</li>
<li>O : 所在行的上方，新建一行</li>
</ul>
</li>
<li>输入–&gt;编辑：<ul>
<li>esc</li>
</ul>
</li>
<li>编辑–&gt;末行<ul>
<li>：</li>
</ul>
</li>
<li>末行–&gt;编辑：<ul>
<li>esc      </li>
</ul>
</li>
</ul>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><ul>
<li>vim +n file： 打开文件，并定位于第n行</li>
<li>vim +: 打开文件，定位于最后一行</li>
<li>vim + /pattern : 打开文件，定位至第一次被PATTERN匹配到的行的行首</li>
</ul>
<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><ul>
<li>末行模式关闭文件<ul>
<li>:q  退出</li>
<li>:wq 保存退出</li>
<li>:!q 不保存并退出</li>
<li>:w  保存</li>
<li>:w! 强行保存</li>
<li>:ADDR1,ADDR2w /path/to/file 将文件的某些行保存到某个文件中去</li>
<li>:r /path/to/somewhere 在当前光标所在行的下方把别的文件添加进来</li>
<li>:qa 退出所有文件</li>
</ul>
</li>
<li>编辑模式下退出<ul>
<li>ZZ</li>
</ul>
</li>
</ul>
<h3 id="移动光标（编辑模式）"><a href="#移动光标（编辑模式）" class="headerlink" title="移动光标（编辑模式）"></a>移动光标（编辑模式）</h3><h4 id="逐字符移动"><a href="#逐字符移动" class="headerlink" title="逐字符移动"></a>逐字符移动</h4><ul>
<li>h ：左</li>
<li>l : 右</li>
<li>j ：下</li>
<li>k : 上</li>
<li>n+方向键： 移动n个字符</li>
</ul>
<h4 id="逐单词移动"><a href="#逐单词移动" class="headerlink" title="逐单词移动"></a>逐单词移动</h4><ul>
<li>w: 移动至下一个单词的次首</li>
<li>e: 移至当前或者下一个单词词尾</li>
<li>b: 跳到当前或前一个单词的词首</li>
<li>都可以和数字组合</li>
</ul>
<h4 id="行内跳转"><a href="#行内跳转" class="headerlink" title="行内跳转"></a>行内跳转</h4><ul>
<li>0：跳到行首</li>
<li>^: 也表示跳到行首, 但是第一个非空字符，绝对行首</li>
<li>$: 绝对行尾</li>
</ul>
<h4 id="行间跳转"><a href="#行间跳转" class="headerlink" title="行间跳转"></a>行间跳转</h4><ul>
<li>n+G: 直接跳转至第n行</li>
<li>G: 最后一行</li>
<li>末行模式下，直接给出行号即可</li>
</ul>
<h4 id="翻屏"><a href="#翻屏" class="headerlink" title="翻屏"></a>翻屏</h4><ul>
<li>ctrl+f：向下翻一屏</li>
<li>ctrl+b: 向上翻一屏</li>
<li>ctrl+d: 向下翻半屏</li>
<li>ctrl+u: 向上翻半屏</li>
</ul>
<h3 id="操作文本"><a href="#操作文本" class="headerlink" title="操作文本"></a>操作文本</h3><h4 id="删除单个字符"><a href="#删除单个字符" class="headerlink" title="删除单个字符"></a>删除单个字符</h4><ul>
<li>x : 删除光标所在处的单个字符</li>
<li>n+x: 删除光标向后n个字符</li>
</ul>
<h4 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h4><ul>
<li>d + 和跳转命令组合使用：指定删除多少</li>
<li>n+d+跳转符：ndw,nde,ndb</li>
<li>dd 删除光标所在行</li>
<li>n+dd 或 D 删除包括当前光标所在内的n行</li>
<li>末行模式下：startADD,endADDd<ul>
<li>. 表示当前行</li>
<li>$ 最后一行</li>
<li>+n: 向下n行</li>
</ul>
</li>
</ul>
<h4 id="粘贴命令"><a href="#粘贴命令" class="headerlink" title="粘贴命令"></a>粘贴命令</h4><ul>
<li>p: 如果删除或复制为整行内容，则粘贴至光标所在行的下方，如果是非整行，则粘贴内容至光标后面</li>
<li>P（大写） ： 前面</li>
</ul>
<h4 id="复制命令"><a href="#复制命令" class="headerlink" title="复制命令"></a>复制命令</h4><ul>
<li>y: 用法和d 相同</li>
</ul>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><ul>
<li>c: 先删除内容，再转换为输入模式，用法和d相同</li>
</ul>
<h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><ul>
<li>r: 替换单个字符</li>
<li>R：直接转换为替换模式</li>
</ul>
<h4 id="撤销编辑操作"><a href="#撤销编辑操作" class="headerlink" title="撤销编辑操作"></a>撤销编辑操作</h4><ul>
<li>u(undo) 可连续使用，一般缓存只保存最近50次的操作</li>
<li>n + u </li>
</ul>
<h4 id="还原撤销操作"><a href="#还原撤销操作" class="headerlink" title="还原撤销操作"></a>还原撤销操作</h4><ul>
<li>ctrl + r</li>
</ul>
<h4 id="重复此前的操作"><a href="#重复此前的操作" class="headerlink" title="重复此前的操作"></a>重复此前的操作</h4><ul>
<li>.</li>
</ul>
<h4 id="可视化模式"><a href="#可视化模式" class="headerlink" title="可视化模式"></a>可视化模式</h4><ul>
<li>v 按字符选取</li>
<li>V 按矩形选取</li>
</ul>
<h4 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h4><ul>
<li><p>/PATTERN 从当前光标所在处，往下去找</p>
</li>
<li><p>?PATTERN 从当前光标所在处，往上去找</p>
</li>
<li><p>n N找下一个</p>
</li>
<li><p>替换: 在末行模式下使用s命令， 用法和sed一样</p>
<blockquote>
<p>ADDR1,ADDR2s@PATTERN@string@gi</p>
</blockquote>
<ul>
<li>1,$或者%：表示全文查找并替换</li>
</ul>
</li>
</ul>
<h3 id="打开多个文件"><a href="#打开多个文件" class="headerlink" title="打开多个文件"></a>打开多个文件</h3><blockquote>
<p>vim FILE1 FILE2</p>
</blockquote>
<ul>
<li>文件间切换<ul>
<li>切换到下一个 末行模式 next</li>
<li>切换到上一个 末行模式 prev </li>
<li>切换至最后一个文件 last</li>
<li>切换至第一个文件 first</li>
</ul>
</li>
<li>分窗口显示多个文件<ul>
<li>vim -o : 水平分割</li>
<li>vim -O : 垂直分割</li>
</ul>
</li>
</ul>
<h3 id="分屏显示文件"><a href="#分屏显示文件" class="headerlink" title="分屏显示文件"></a>分屏显示文件</h3><ul>
<li>Ctrl+w, s: 水平拆分窗口</li>
<li>Ctrl+w, v: 垂直拆分窗口</li>
<li>在窗口间切换光标： Ctrl+w,ARROW</li>
</ul>
<h3 id="跟shell交互"><a href="#跟shell交互" class="headerlink" title="跟shell交互"></a>跟shell交互</h3><p>:!COMMAND</p>
<h3 id="高级话题"><a href="#高级话题" class="headerlink" title="高级话题"></a>高级话题</h3><ul>
<li>:set nu  显示行号</li>
<li>:set nonu 取消显示行号</li>
<li>:set ai 设定自动缩进</li>
<li>:set noai 取消自动缩进</li>
<li>:set hlsearch 高亮显示搜索到的文本</li>
<li>:set nohlsearch 取消高亮显示搜索到的文本</li>
<li>:syntax on 开启语法着色</li>
<li>:syntax off 关闭语法着色</li>
</ul>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul>
<li>/etc/vimrc </li>
<li>个人配置文件 家目录/.vimrc</li>
</ul>
<h3 id="vim教程"><a href="#vim教程" class="headerlink" title="vim教程"></a>vim教程</h3><blockquote>
<p>vimtutor </p>
</blockquote>
<h2 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h2><h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3><ul>
<li>非实时，模糊匹配，查找是根据全系统文件数据库进行的 </li>
<li>updatedb 手动生成文件数据库</li>
<li>速度快</li>
</ul>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><ul>
<li>实时 精确 遍历指定目录中的所有文件完成查找 速度慢 支持多种查找标准<blockquote>
<p>find 查找路径 查找标准 查找到以后的处理动作</p>
</blockquote>
</li>
<li>查找路径： 默认为当前目录</li>
<li>查找标准： 默认为指定路径下的所有文件</li>
<li>处理动作： 默认为打印</li>
<li>匹配标准<ul>
<li>-name ‘FILENAME’, 对文件名作精确匹配，支持文件名通配</li>
<li>-iname ‘FILENAME’, 文件名匹配不区分大小写</li>
<li>-regex PATTERN: 基于正则表达式进行文件名匹配</li>
<li>-user USERNAME: 根据USER查找</li>
<li>-group</li>
<li>-uid</li>
<li>-gid</li>
<li>-nouser</li>
<li>-type 根据文件文件类型来查找 f,d,c,b,l等</li>
<li>-size [+(大于)|-（小于）] nk,nM,nG,</li>
</ul>
</li>
<li>组合条件<ul>
<li>默认为与  </li>
<li>-a 与</li>
<li>-o 或</li>
<li>-not 非 </li>
</ul>
</li>
<li>根据时间查找<ul>
<li>-mtime 修改时间 </li>
<li>-ctime 改变时间</li>
<li>-atime 访问时间 -atime 5 刚好五天没有访问过</li>
<li>[+|-]5  -atime +5 至少五天没有访问过 -atime -5 五天之内访问过</li>
<li>-mmin -cmin -amin 分钟</li>
</ul>
</li>
<li>根据权限查找<ul>
<li>-perm mode 权限精确匹配 -perm 644</li>
<li>-perm -mode 包含匹配 -perm -644 可以匹配到755的文件</li>
</ul>
</li>
<li>运作<ul>
<li>-print:显示</li>
<li>-ls: 类似ls -l的形式显示每一个文件的详细</li>
<li>-ok COMMAND {} ; <strong>空格 反斜线 分号 缺一不可</strong> 每一次操作都需要用户确认; {}表示引用查找到的结果</li>
<li>-exec COMMAND {} ;</li>
<li>|xargs 可以不用占位符<blockquote>
<p>find /etc -size +1M | xargs echo &gt;&gt; /tmp/etc.largefiles </p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h2><ul>
<li><p>SUID： 运行某程序时，相应进程的属主是程序文件自身的属主，而不是启动者</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod u+s FILE</span><br><span class="line">chmod u-s FILE</span><br><span class="line">如果FILE本身有执行权限，则SUID显示为s，否则显示S；</span><br></pre></td></tr></table></figure>
</li>
<li><p>SGID： 运行某程序时，相应进程的属主是程序文件自身的属组，而不是启动者</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod g+s FILE</span><br><span class="line">chmod g-s FILE</span><br><span class="line">(应用场景：给目录加SGID,在目录中添加文件的用户的组都不是自己的基本组，而是目录的基本组，也就是说用户可以享有相互修改和删除文件的权限)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Sticky: 在一个公共目录，每个用户都可以创建文件，删除自己的文件，但不能删除别人的文件</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod o+t DIR</span><br><span class="line">chmod o-t DIR</span><br></pre></td></tr></table></figure>
</li>
<li><p>sst 也可以对应相应的二进制：000，001，010，011，100，101，110，111</p>
<blockquote>
<p>chmod 5755 /backup/test (把文件权限改成: rws-r-x-r-t)</p>
</blockquote>
</li>
</ul>
<h2 id="FACL"><a href="#FACL" class="headerlink" title="FACL"></a>FACL</h2><p>FileSystem Access Control List<br>利用文件扩展保存额外的访问控制权限<br><strong>正常流程 owner-&gt;group-&gt;other</strong><br><strong>facl流程 owner-&gt;facl,user-&gt;group-&gt;facl-&gt;facl,group-&gt;other</strong></p>
<ul>
<li>setfacl<ul>
<li>-m : 设定<ul>
<li>u:用户名:perm</li>
<li>g:组名:perm</li>
</ul>
</li>
<li>-x : 取消<ul>
<li>u:用户名</li>
<li>g:组名 </li>
</ul>
</li>
</ul>
</li>
<li>getfacl</li>
<li>–mask </li>
</ul>
<h2 id="who"><a href="#who" class="headerlink" title="who"></a>who</h2><ul>
<li>whoami 打印当前有效的用户名</li>
<li>who 显示当前系统谁在登录</li>
<li>w 显示登录信息</li>
<li>which 寻找命令位置 type 显示命令类型</li>
<li>whereis 搜索特定文件, 后面跟文件或目录的名字 </li>
<li>last 显示/var/log/wtmp文件，显示用户登录历史及系统重启历史<ul>
<li>-n 数字：显示最近多少次的相关信息</li>
</ul>
</li>
<li>lastb 显示/var/log/btmp文件，显示用户的错误登录尝试</li>
<li>lastlog 显示每一个用户最近一次的成功登录信息<ul>
<li>-u USERNAME: 显示特定用户最近的登录信息</li>
</ul>
</li>
<li>hostname 显示当前主机名</li>
<li>basename 去掉路径名，只保留文件名</li>
<li>$RANDOM 0~32768之间的随机数值</li>
<li>du 打印目录中所有文件以及目录本身的大小<ul>
<li>-s 仅打印目录本身的大小</li>
<li>-h 进行数据的单位换算</li>
</ul>
</li>
</ul>
<h2 id="磁盘管理及文件链接"><a href="#磁盘管理及文件链接" class="headerlink" title="磁盘管理及文件链接"></a>磁盘管理及文件链接</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul>
<li><p>硬链接 表示两个文件指向同一个inode(索引节点)</p>
<blockquote>
<p>ln SRC DEST</p>
</blockquote>
<ul>
<li>只能对文件创建，不能应用于目录</li>
<li>不能跨文件系统</li>
<li>创建硬链接会增加文件被硬链接的次数</li>
</ul>
</li>
<li><p>符号链接  一个文件的内容为另一个文件的路径</p>
<blockquote>
<p>ln -s SRC DEST    </p>
</blockquote>
<ul>
<li>可应用于目录</li>
<li>可以跨文件系统</li>
<li>不会增加被链接文件的链接次数</li>
<li>其大小为路径所包含的字符个数 </li>
</ul>
</li>
</ul>
<h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><ul>
<li>df 评估一个分区磁盘块的使用情况以及inode的使用情况</li>
</ul>
<h3 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a>设备文件</h3><ul>
<li><p>存放在/dev目录下，都有两个数字</p>
<ul>
<li>主设备号(major number) 标识设备类型</li>
<li>次设备号(minor number) 标识同一类型中的不同设备 </li>
</ul>
</li>
<li><p>b: 按块为单位，随机访问的设备，比如硬盘</p>
</li>
<li><p>c 按字符为单位，线性设备</p>
</li>
<li><p>创建设备文件</p>
<blockquote>
<p>mknod 设备名称 设备类型（b/c） 主设备号 次设备号</p>
</blockquote>
</li>
<li><p>列出当前系统所有磁盘以及磁盘分区</p>
<blockquote>
<p>fdisk -l</p>
</blockquote>
</li>
<li><p>管理磁盘分区</p>
<blockquote>
<p>fdisk /dev/sda (进入交互界面)</p>
</blockquote>
<ul>
<li>p : 显示当前硬件的分区，包括没保存的改动</li>
<li>n : 创建新分区</li>
<li>d : 删除一个分区</li>
<li>w : 保存退出</li>
<li>q : 不保存退出</li>
<li>t : 修改分区类型</li>
<li>l : 显示所支持的所有类型  </li>
</ul>
</li>
</ul>
<h3 id="linux支持的文件系统"><a href="#linux支持的文件系统" class="headerlink" title="linux支持的文件系统"></a>linux支持的文件系统</h3><ul>
<li>文件系统属于内核功能，每一个分区可以使用不同的文件系统，而最后都要归并到根目录下，归并的方式成为挂载</li>
<li>VFS: VIRTURL FILE SYSTEM</li>
<li>高级格式化： 创建文件系统<blockquote>
<p>mkfs -t ext3 (创建一个ext3类型的文件系统)</p>
</blockquote>
</li>
</ul>
<h2 id="压缩-解压缩命令"><a href="#压缩-解压缩命令" class="headerlink" title="压缩 解压缩命令"></a>压缩 解压缩命令</h2><ul>
<li><p>压缩格式： gz,bz2,xz,zip,Z</p>
</li>
<li><p>压缩算法: 算法不同，压缩比也会不同</p>
</li>
<li><p>常用：xz,bz2,gz(只能压缩文件，不能压缩目录，删除源文件，只保留压缩后的文件)</p>
</li>
<li><p>命令</p>
<ul>
<li><p>压缩</p>
<blockquote>
<p>gzip file</p>
</blockquote>
</li>
<li><p>解压缩 </p>
<blockquote>
<p>gunzip file<br>gzip -d file<br>gzip -n 1-9 指定压缩比 默认是6</p>
</blockquote>
</li>
<li><p>bzip2 比gzip对于大文件压缩效果明显 使用格式近似</p>
<ul>
<li>-k 保留压缩源文件</li>
</ul>
</li>
<li><p>xz 用法相同，压缩比更大 解压 unxz </p>
</li>
<li><p>zip 既归档又可以压缩目录</p>
<blockquote>
<p>zip FILENAME.zip FILE1 FILE2… 压缩后不删除源文件<br>unzip FILENAME.zip</p>
</blockquote>
</li>
<li><p>tar: 只归档不压缩</p>
<ul>
<li>-c : 创建归档文件</li>
<li>-f FILE.tar: 操作的归档文件</li>
<li>-x 展开归档文件</li>
<li>–xattrs 归档时，保留文件的扩展属性信息</li>
<li>-t 不展开归档，查看内部文件</li>
<li>-zcf: 先归档再用gzip压缩  </li>
<li>-zxf: 先用gzip解压缩，并展开归档, -z 选项可以省略</li>
<li>-jcf: bzip2</li>
<li>-jxf: </li>
<li>-Jcf: xz</li>
<li>-Jxf</li>
<li>-p 保留备份数据的原始权限和属性</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown语法练习</title>
    <url>/2016/07/13/Markdown%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>熟练一下 <strong>Markdown</strong> 语法，以后每学一点东西都要做笔记</p>
<a id="more"></a>
<!-- toc -->

<h3 id="1-Markdown-语法有以下几个作用："><a href="#1-Markdown-语法有以下几个作用：" class="headerlink" title="1. Markdown 语法有以下几个作用："></a>1. <strong>Markdown</strong> 语法有以下几个作用：</h3><blockquote>
<ul>
<li>整理知识学习笔记</li>
<li>发布日记 杂文 所见所想</li>
<li>发布小说</li>
</ul>
</blockquote>
<h3 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2. 分级标题"></a>2. 分级标题</h3><h4 id="H4"><a href="#H4" class="headerlink" title="H4"></a>H4</h4><h5 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h5><h3 id="3-外链接"><a href="#3-外链接" class="headerlink" title="3. 外链接"></a>3. 外链接</h3><p><img src="https://www.zybuluo.com/static/img/logo.png" alt="markdownlogo"><br>这是<a href="https://www.tricrepe.com" target="_blank" rel="noopener"><strong>我小说的地址</strong></a></p>
<h3 id="4-文字"><a href="#4-文字" class="headerlink" title="4. 文字"></a>4. 文字</h3><blockquote>
<p>我是引用</p>
</blockquote>
<p>我是 <strong>粗体文字</strong><br>我是  <em>斜体</em><br>我是<code>区域高亮</code></p>
<h3 id="5-无序列表"><a href="#5-无序列表" class="headerlink" title="5. 无序列表"></a>5. 无序列表</h3><p>我是无序列表：</p>
<ul>
<li>无序列表1</li>
<li>无序列表2</li>
<li>无需列表3</li>
</ul>
<h3 id="6-有序列表"><a href="#6-有序列表" class="headerlink" title="6. 有序列表"></a>6. 有序列表</h3><p>我是有序列表：</p>
<ol>
<li>有序列表1</li>
<li>有序列表2</li>
</ol>
<h3 id="7-代码块"><a href="#7-代码块" class="headerlink" title="7. 代码块"></a>7. 代码块</h3><p>四个空格：</p>
<pre><code>这是一个代码块，此行左侧有四个不可见的空格。
第二行试试。</code></pre><h3 id="8-加强代码块"><a href="#8-加强代码块" class="headerlink" title="8. 加强代码块"></a>8. 加强代码块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&#39;index.js&#39;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>NodeJS笔记</title>
    <url>/2016/06/14/note_nodejs/</url>
    <content><![CDATA[<p>nodejs 学习笔记</p>
<a id="more"></a>

<h1 id="nodejs特点"><a href="#nodejs特点" class="headerlink" title="nodejs特点"></a>nodejs特点</h1><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><ol>
<li>java, php或.net等服务器语言，每个客户端创建一个新的线程，都要耗费2M内存，而nodejs仅仅使用一个线程。</li>
<li>单线程也能造成宏观上的并发</li>
</ol>
<p>##非阻塞I/O<br>当某个IO执行完毕时，将以时间的形式通知执行IO操作的线程，线程执行这个事件的回调函数，为了处理异步IO，线程必须有事件循环，不断检查有没有未处理的事件，依次予以处理。</p>
<p>##事件驱动<br>事件分配，nodejs底层代码，近半数都用于事件队列、回调函数队列构建<br>不管是新用户请求，还是老用户IO完成，都将以事件方式键入事件环，等待调度</p>
<p>##适合开发什么<br>适合IO，不适合计算<br>用户表单收集<br>考试系统<br>聊天室（长连接）</p>
<ul>
<li>node能直接运行任何一个js文件，node是个js的执行环境</li>
<li>nodejs 没有根目录的概念，因为它根本没有web容器</li>
<li>字符串查询用querysrting.parse</li>
<li>url.parse如果第二个参数是true，就可以将所有的查询变成字符串，就可以打点得到这个参数.</li>
</ul>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><ul>
<li>Node约定，如果某个函数需要回调函数作为参数，则回调函数是最后一个参数。<pre><code>var isTrue = function(value, callback) {
      if (value === true) {
        callback(null, &quot;Value was true.&quot;);
      }
      else {
        callback(new Error(&quot;Value is not true!&quot;));
      }
}</code></pre></li>
<li>另外，回调函数本身的第一个参数，约定为上一步传入的错误对象。<pre><code>var callback = function(error,value){
    if(error){
        return console.log(error);
    }
    console.log(value)
}</code></pre></li>
<li>callback函数第一个参数是err的原因是，因为执行异步，前期操作的错误无法被try catch 语句检测到</li>
</ul>
<h2 id="全局对象和全局变量"><a href="#全局对象和全局变量" class="headerlink" title="全局对象和全局变量"></a>全局对象和全局变量</h2><h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><ul>
<li>所有对象都可调用</li>
<li>global</li>
<li>process</li>
<li>console</li>
</ul>
<h3 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a>全局函数</h3><ul>
<li>setTimeout()</li>
<li>clearTimeout()</li>
<li>setInterval()</li>
<li>clearInterval()</li>
<li>require()</li>
</ul>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><ul>
<li>__filename 指向当前运行脚本的文件名</li>
<li>__dirname  指向当前运行脚本所在目录</li>
</ul>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><blockquote>
<p>var circle = require(‘./circle’)  //包含路径的情况<br>var http = require(‘http’)  // 不包含路径的情况，去node的安装目录里找</p>
</blockquote>
<ul>
<li>导入模块其实就是导入js文件</li>
</ul>
<h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><blockquote>
<p>http：提供HTTP服务器功能。<br>url：解析URL。<br>fs：与文件系统交互。<br>querystring：解析URL的查询字符串。<br>child_process：新建子进程。<br>util：提供一系列实用小工具。<br>path：处理文件路径。<br>crypto：提供加密和解密功能，基本上是对OpenSSL的包装。</p>
</blockquote>
<ul>
<li>核心模块式优先加载的，如果自己写了一个HTTP模块，<code>require(&#39;http&#39;)</code>加载的还是核心模块。</li>
</ul>
<h1 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h1>]]></content>
      <categories>
        <category>程序</category>
      </categories>
  </entry>
  <entry>
    <title>讲讲CSS动画的贝塞尔曲线</title>
    <url>/2016/06/02/CSS%E5%8A%A8%E7%94%BB%E7%9A%84%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/</url>
    <content><![CDATA[<p>讲讲运动的平滑性</p>
<a id="more"></a>

<p>（转载请注明出处）</p>
<p><img src="http://www.tricrepe.com/wp-content/uploads/2016/06/bezier-curve.jpg" alt="bezier-curve"></p>
<p>现在web端的动画越来越倾向于用CSS直接写了，浏览器支持越来越好，代码写起来也直观，更重要的是，你可以真正拥有Animation的创作自由。当然你可以说装个JS的动画库更简便，我只能说很多动画库的动态效果都老掉牙了，而且这些库的动画效果也是用CSS定义的。你如果明白了原理，写一个合自己心意的动态效果岂不是更好。</p>
<p>坐标轴、翻转、移动、透视这些基础的东西我就不讲了，我只讲一下可以让运动看起来更自然的Animation-Timing-Function属性。</p>
<p>Animation-Timing-Function属性通俗点讲是控制元素运动速度变化的，默认值是ease，指的是元素以低速开始运动，然后加快，在结束前变慢。</p>
<p>你也可以设置其他的值，比如linear（匀速运动），ease-in（低速开始，渐渐加快），ease-out（高速开始，渐渐变慢），ease-in-out（低速开始，中间加快，最后低速结束。看起来和ease差不多，但有所区别）。</p>
<p>这些键值定义的很模糊，也不好记（至少我记不住），而且最关键的一点——这几种运动很生硬，如果你想做生动一点的动态效果，根本用不上。</p>
<p>那么现在就讲讲最后Animation-Timing-Function的最后一个键值——cubic-bezier（中文叫贝塞尔曲线）吧。</p>
<p>如果你觉得这个键值拗口，再看看网上高深的三次、四次、五次贝塞尔方程，把它想象的很复杂而拒绝使用的话，那就大错特错了。</p>
<p>可以先看看这几条贝塞尔曲线：<img src="http://www.tricrepe.com/wp-content/uploads/2016/06/cubic_bezier_1.jpg" alt="cubic_bezier_1"></p>
<p>其实是几个用英文命名的键值，也是用贝塞尔曲线设定的，想象这些曲线出现在坐标系里，坐标原点（0，0）代表元素运动的起点，坐标点（1，1）代表元素运动的终点，x轴代表时间，y轴代表元素运动经过路径的百分比。贝塞尔曲线就是坐标轴上从（0，0）到（1，1）的曲线。这样元素运动速度的变化也很直观了，就是曲线上某个点的切线于x轴夹角的变化。</p>
<p>记住这几条曲线的形状，就能很快理解ease是怎么运动的。当然，即使这样我还是不推荐用ease开头的这些运动方式。</p>
<p>那么如何定义一条自己的贝塞尔运动曲线呢？国外有一个不错的工具网站会有助于理解。<a href="http://cubic-bezier.com/" target="_blank" rel="noopener">http://cubic-bezier.com/</a><br><img src="http://www.tricrepe.com/wp-content/uploads/2016/06/3.pic_-297x300.jpg" alt="3.pic"><br><img src="http://www.tricrepe.com/wp-content/uploads/2016/06/5.pic_-300x25.jpg" alt="5.pic"></p>
<p>抛开起点（0，0）和终点（1，1）两者不谈，一条贝塞尔曲线的形状是由图中红色和绿色两个点定义出来的，代码里贝塞尔曲线的参数也是这两个点的坐标值。调整这两个点的位置，得到不同的曲线，就有不同的运动方式，就这么简单。</p>
<p>但问题复杂的地方在于，很多运动并不是用一条贝塞尔曲线就能描述清楚的，比如：</p>
<iframe src="http://tricrepe.github.io/bouncing-ball/" width="500px" height="300px" frameborder="0">
</iframe>

<p>把鼠标悬停在蓝色小球上，就会得到小球的跳跃运动，这种反复的上下运动是无法用一条贝塞尔曲线做出来的，怎么做呢？</p>
<p>——通过关键帧定义多条贝塞尔曲线</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bounce</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line"><span class="attribute">animation-name</span>: bounce;</span><br><span class="line"><span class="attribute">transform-origin</span>: center bottom;</span><br><span class="line"><span class="attribute">animation-duration</span>: <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> bounce &#123;</span><br><span class="line"><span class="selector-tag">from</span>, 53%, 80%, <span class="selector-tag">to</span> &#123;</span><br><span class="line"><span class="attribute">animation-timing-function</span>: <span class="built_in">cubic-bezier</span>(<span class="number">0.215</span>, <span class="number">0.610</span>, <span class="number">0.355</span>, <span class="number">1.000</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">40%&#123;</span><br><span class="line"><span class="attribute">animation-timing-function</span>: <span class="built_in">cubic-bezier</span>(<span class="number">0.755</span>, <span class="number">0.050</span>, <span class="number">0.855</span>, <span class="number">0.060</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>, -<span class="number">300px</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">70% &#123;</span><br><span class="line"><span class="attribute">animation-timing-function</span>: <span class="built_in">cubic-bezier</span>(<span class="number">0.755</span>, <span class="number">0.050</span>, <span class="number">0.855</span>, <span class="number">0.060</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>, -<span class="number">150px</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">90% &#123;</span><br><span class="line"><span class="attribute">animation-timing-function</span>: <span class="built_in">cubic-bezier</span>(<span class="number">0.755</span>, <span class="number">0.050</span>, <span class="number">0.855</span>, <span class="number">0.060</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>,-<span class="number">40px</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了起点和终点之外，我定义了5个关键帧，40%，70%和90%的地方分别定义了小球落下时衰减的高度，而0%，53%，80%和100%处，小球则处于地平线的位置，每个关键帧的过渡都用贝赛尔曲线完成。</p>
<p>整个运动又6条贝塞尔曲线组成：</p>
<p>0%-40%  cubic-bezier(0.755, 0.050, 0.855, 0.060)</p>
<p>40%-53% cubic-bezier(0.215, 0.610, 0.355, 1.000)</p>
<p>53%-70%  cubic-bezier(0.755, 0.050, 0.855, 0.060)</p>
<p>70%-80% cubic-bezier(0.215, 0.610, 0.355, 1.000)</p>
<p>80%-90% cubic-bezier(0.755, 0.050, 0.855, 0.060)</p>
<p>90%-100% cubic-bezier(0.215, 0.610, 0.355, 1.000)</p>
<p>这样一个小球跳跃的运动就写出来了，注意，不要把贝塞尔曲线和元素的运动轨迹混淆，贝塞尔曲线是用来控制元素运动速度变化的。</p>
<p>还有更多的动态效果就不再一一讲了，比如摇晃、抖动、掉落、弹性弹出，都是通过关键帧用贝塞尔曲线拼接而成，像自由落体这种运动，还可以通过sass写出精准的计算公式出来。</p>
<p>总之，看到好的动态效果不妨模仿一下，有一天，你也能写出你自己的动态效果。</p>
<p>&nbsp;</p>
]]></content>
      <categories>
        <category>设计</category>
      </categories>
  </entry>
  <entry>
    <title>Contact Card Design</title>
    <url>/2016/05/30/contact-card-design/</url>
    <content><![CDATA[<p>网址： <a href="http://tricrepe.github.io/contact-card/">http://tricrepe.github.io/contact-card/</a></p>
<iframe src="http://tricrepe.github.io/contact-card/" width="800" height="400" frameborder="0"></iframe>]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>Testing</tag>
      </tags>
  </entry>
</search>
